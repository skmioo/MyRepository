// Generated by the protocol buffer compiler.  DO NOT EDIT!
// source: HappyRollMessage.proto

#define INTERNAL_SUPPRESS_PROTOBUF_FIELD_DEPRECATION
#include "HappyRollMessage.pb.h"

#include <algorithm>

#include <google/protobuf/stubs/common.h>
#include <google/protobuf/stubs/once.h>
#include <google/protobuf/io/coded_stream.h>
#include <google/protobuf/wire_format_lite_inl.h>
#include <google/protobuf/descriptor.h>
#include <google/protobuf/generated_message_reflection.h>
#include <google/protobuf/reflection_ops.h>
#include <google/protobuf/wire_format.h>
// @@protoc_insertion_point(includes)

namespace {

const ::google::protobuf::Descriptor* HRRewardInfo_descriptor_ = NULL;
const ::google::protobuf::internal::GeneratedMessageReflection*
  HRRewardInfo_reflection_ = NULL;
const ::google::protobuf::Descriptor* ShowInfo_descriptor_ = NULL;
const ::google::protobuf::internal::GeneratedMessageReflection*
  ShowInfo_reflection_ = NULL;
const ::google::protobuf::Descriptor* HRInfo_descriptor_ = NULL;
const ::google::protobuf::internal::GeneratedMessageReflection*
  HRInfo_reflection_ = NULL;
const ::google::protobuf::Descriptor* CGHappyRoll_descriptor_ = NULL;
const ::google::protobuf::internal::GeneratedMessageReflection*
  CGHappyRoll_reflection_ = NULL;
const ::google::protobuf::Descriptor* GCHappyRoll_descriptor_ = NULL;
const ::google::protobuf::internal::GeneratedMessageReflection*
  GCHappyRoll_reflection_ = NULL;
const ::google::protobuf::Descriptor* GCHappyRollRewardList_descriptor_ = NULL;
const ::google::protobuf::internal::GeneratedMessageReflection*
  GCHappyRollRewardList_reflection_ = NULL;
const ::google::protobuf::Descriptor* GCHappyRollJackPotList_descriptor_ = NULL;
const ::google::protobuf::internal::GeneratedMessageReflection*
  GCHappyRollJackPotList_reflection_ = NULL;
const ::google::protobuf::Descriptor* CGLottery_descriptor_ = NULL;
const ::google::protobuf::internal::GeneratedMessageReflection*
  CGLottery_reflection_ = NULL;
const ::google::protobuf::Descriptor* GCLottery_descriptor_ = NULL;
const ::google::protobuf::internal::GeneratedMessageReflection*
  GCLottery_reflection_ = NULL;
const ::google::protobuf::Descriptor* CGHappyRollGetReward_descriptor_ = NULL;
const ::google::protobuf::internal::GeneratedMessageReflection*
  CGHappyRollGetReward_reflection_ = NULL;
const ::google::protobuf::Descriptor* GCHappyRollGetRewardBack_descriptor_ = NULL;
const ::google::protobuf::internal::GeneratedMessageReflection*
  GCHappyRollGetRewardBack_reflection_ = NULL;
const ::google::protobuf::Descriptor* CGCheckHRUpdate_descriptor_ = NULL;
const ::google::protobuf::internal::GeneratedMessageReflection*
  CGCheckHRUpdate_reflection_ = NULL;
const ::google::protobuf::Descriptor* GCVersion_descriptor_ = NULL;
const ::google::protobuf::internal::GeneratedMessageReflection*
  GCVersion_reflection_ = NULL;
const ::google::protobuf::Descriptor* CGHappyRollBuyMoney_descriptor_ = NULL;
const ::google::protobuf::internal::GeneratedMessageReflection*
  CGHappyRollBuyMoney_reflection_ = NULL;

}  // namespace


void protobuf_AssignDesc_HappyRollMessage_2eproto() {
  protobuf_AddDesc_HappyRollMessage_2eproto();
  const ::google::protobuf::FileDescriptor* file =
    ::google::protobuf::DescriptorPool::generated_pool()->FindFileByName(
      "HappyRollMessage.proto");
  GOOGLE_CHECK(file != NULL);
  HRRewardInfo_descriptor_ = file->message_type(0);
  static const int HRRewardInfo_offsets_[6] = {
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(HRRewardInfo, iteminfo_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(HRRewardInfo, consumebid_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(HRRewardInfo, consumesid_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(HRRewardInfo, consumevalue_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(HRRewardInfo, isshow_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(HRRewardInfo, id_),
  };
  HRRewardInfo_reflection_ =
    new ::google::protobuf::internal::GeneratedMessageReflection(
      HRRewardInfo_descriptor_,
      HRRewardInfo::default_instance_,
      HRRewardInfo_offsets_,
      GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(HRRewardInfo, _has_bits_[0]),
      GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(HRRewardInfo, _unknown_fields_),
      -1,
      ::google::protobuf::DescriptorPool::generated_pool(),
      ::google::protobuf::MessageFactory::generated_factory(),
      sizeof(HRRewardInfo));
  ShowInfo_descriptor_ = file->message_type(1);
  static const int ShowInfo_offsets_[2] = {
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(ShowInfo, id_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(ShowInfo, num_),
  };
  ShowInfo_reflection_ =
    new ::google::protobuf::internal::GeneratedMessageReflection(
      ShowInfo_descriptor_,
      ShowInfo::default_instance_,
      ShowInfo_offsets_,
      GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(ShowInfo, _has_bits_[0]),
      GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(ShowInfo, _unknown_fields_),
      -1,
      ::google::protobuf::DescriptorPool::generated_pool(),
      ::google::protobuf::MessageFactory::generated_factory(),
      sizeof(ShowInfo));
  HRInfo_descriptor_ = file->message_type(2);
  static const int HRInfo_offsets_[9] = {
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(HRInfo, rewardlist_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(HRInfo, starttime_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(HRInfo, endtime_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(HRInfo, jackpotscore_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(HRInfo, jackpotmoney_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(HRInfo, percent_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(HRInfo, integral_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(HRInfo, maxselectnum_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(HRInfo, lastpond_),
  };
  HRInfo_reflection_ =
    new ::google::protobuf::internal::GeneratedMessageReflection(
      HRInfo_descriptor_,
      HRInfo::default_instance_,
      HRInfo_offsets_,
      GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(HRInfo, _has_bits_[0]),
      GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(HRInfo, _unknown_fields_),
      -1,
      ::google::protobuf::DescriptorPool::generated_pool(),
      ::google::protobuf::MessageFactory::generated_factory(),
      sizeof(HRInfo));
  CGHappyRoll_descriptor_ = file->message_type(3);
  static const int CGHappyRoll_offsets_[1] = {
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(CGHappyRoll, type_),
  };
  CGHappyRoll_reflection_ =
    new ::google::protobuf::internal::GeneratedMessageReflection(
      CGHappyRoll_descriptor_,
      CGHappyRoll::default_instance_,
      CGHappyRoll_offsets_,
      GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(CGHappyRoll, _has_bits_[0]),
      GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(CGHappyRoll, _unknown_fields_),
      -1,
      ::google::protobuf::DescriptorPool::generated_pool(),
      ::google::protobuf::MessageFactory::generated_factory(),
      sizeof(CGHappyRoll));
  GCHappyRoll_descriptor_ = file->message_type(4);
  static const int GCHappyRoll_offsets_[3] = {
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(GCHappyRoll, type_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(GCHappyRoll, hrinfo_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(GCHappyRoll, havemoneynum_),
  };
  GCHappyRoll_reflection_ =
    new ::google::protobuf::internal::GeneratedMessageReflection(
      GCHappyRoll_descriptor_,
      GCHappyRoll::default_instance_,
      GCHappyRoll_offsets_,
      GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(GCHappyRoll, _has_bits_[0]),
      GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(GCHappyRoll, _unknown_fields_),
      -1,
      ::google::protobuf::DescriptorPool::generated_pool(),
      ::google::protobuf::MessageFactory::generated_factory(),
      sizeof(GCHappyRoll));
  GCHappyRollRewardList_descriptor_ = file->message_type(5);
  static const int GCHappyRollRewardList_offsets_[3] = {
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(GCHappyRollRewardList, hrrewardlist_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(GCHappyRollRewardList, hrmullist_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(GCHappyRollRewardList, hrmuldeslist_),
  };
  GCHappyRollRewardList_reflection_ =
    new ::google::protobuf::internal::GeneratedMessageReflection(
      GCHappyRollRewardList_descriptor_,
      GCHappyRollRewardList::default_instance_,
      GCHappyRollRewardList_offsets_,
      GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(GCHappyRollRewardList, _has_bits_[0]),
      GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(GCHappyRollRewardList, _unknown_fields_),
      -1,
      ::google::protobuf::DescriptorPool::generated_pool(),
      ::google::protobuf::MessageFactory::generated_factory(),
      sizeof(GCHappyRollRewardList));
  GCHappyRollJackPotList_descriptor_ = file->message_type(6);
  static const int GCHappyRollJackPotList_offsets_[1] = {
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(GCHappyRollJackPotList, shows_),
  };
  GCHappyRollJackPotList_reflection_ =
    new ::google::protobuf::internal::GeneratedMessageReflection(
      GCHappyRollJackPotList_descriptor_,
      GCHappyRollJackPotList::default_instance_,
      GCHappyRollJackPotList_offsets_,
      GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(GCHappyRollJackPotList, _has_bits_[0]),
      GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(GCHappyRollJackPotList, _unknown_fields_),
      -1,
      ::google::protobuf::DescriptorPool::generated_pool(),
      ::google::protobuf::MessageFactory::generated_factory(),
      sizeof(GCHappyRollJackPotList));
  CGLottery_descriptor_ = file->message_type(7);
  static const int CGLottery_offsets_[2] = {
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(CGLottery, choserewardidlist_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(CGLottery, chosemultiple_),
  };
  CGLottery_reflection_ =
    new ::google::protobuf::internal::GeneratedMessageReflection(
      CGLottery_descriptor_,
      CGLottery::default_instance_,
      CGLottery_offsets_,
      GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(CGLottery, _has_bits_[0]),
      GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(CGLottery, _unknown_fields_),
      -1,
      ::google::protobuf::DescriptorPool::generated_pool(),
      ::google::protobuf::MessageFactory::generated_factory(),
      sizeof(CGLottery));
  GCLottery_descriptor_ = file->message_type(8);
  static const int GCLottery_offsets_[3] = {
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(GCLottery, result_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(GCLottery, targetid_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(GCLottery, integral_),
  };
  GCLottery_reflection_ =
    new ::google::protobuf::internal::GeneratedMessageReflection(
      GCLottery_descriptor_,
      GCLottery::default_instance_,
      GCLottery_offsets_,
      GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(GCLottery, _has_bits_[0]),
      GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(GCLottery, _unknown_fields_),
      -1,
      ::google::protobuf::DescriptorPool::generated_pool(),
      ::google::protobuf::MessageFactory::generated_factory(),
      sizeof(GCLottery));
  CGHappyRollGetReward_descriptor_ = file->message_type(9);
  static const int CGHappyRollGetReward_offsets_[1] = {
  };
  CGHappyRollGetReward_reflection_ =
    new ::google::protobuf::internal::GeneratedMessageReflection(
      CGHappyRollGetReward_descriptor_,
      CGHappyRollGetReward::default_instance_,
      CGHappyRollGetReward_offsets_,
      GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(CGHappyRollGetReward, _has_bits_[0]),
      GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(CGHappyRollGetReward, _unknown_fields_),
      -1,
      ::google::protobuf::DescriptorPool::generated_pool(),
      ::google::protobuf::MessageFactory::generated_factory(),
      sizeof(CGHappyRollGetReward));
  GCHappyRollGetRewardBack_descriptor_ = file->message_type(10);
  static const int GCHappyRollGetRewardBack_offsets_[1] = {
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(GCHappyRollGetRewardBack, result_),
  };
  GCHappyRollGetRewardBack_reflection_ =
    new ::google::protobuf::internal::GeneratedMessageReflection(
      GCHappyRollGetRewardBack_descriptor_,
      GCHappyRollGetRewardBack::default_instance_,
      GCHappyRollGetRewardBack_offsets_,
      GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(GCHappyRollGetRewardBack, _has_bits_[0]),
      GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(GCHappyRollGetRewardBack, _unknown_fields_),
      -1,
      ::google::protobuf::DescriptorPool::generated_pool(),
      ::google::protobuf::MessageFactory::generated_factory(),
      sizeof(GCHappyRollGetRewardBack));
  CGCheckHRUpdate_descriptor_ = file->message_type(11);
  static const int CGCheckHRUpdate_offsets_[1] = {
  };
  CGCheckHRUpdate_reflection_ =
    new ::google::protobuf::internal::GeneratedMessageReflection(
      CGCheckHRUpdate_descriptor_,
      CGCheckHRUpdate::default_instance_,
      CGCheckHRUpdate_offsets_,
      GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(CGCheckHRUpdate, _has_bits_[0]),
      GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(CGCheckHRUpdate, _unknown_fields_),
      -1,
      ::google::protobuf::DescriptorPool::generated_pool(),
      ::google::protobuf::MessageFactory::generated_factory(),
      sizeof(CGCheckHRUpdate));
  GCVersion_descriptor_ = file->message_type(12);
  static const int GCVersion_offsets_[1] = {
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(GCVersion, version_),
  };
  GCVersion_reflection_ =
    new ::google::protobuf::internal::GeneratedMessageReflection(
      GCVersion_descriptor_,
      GCVersion::default_instance_,
      GCVersion_offsets_,
      GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(GCVersion, _has_bits_[0]),
      GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(GCVersion, _unknown_fields_),
      -1,
      ::google::protobuf::DescriptorPool::generated_pool(),
      ::google::protobuf::MessageFactory::generated_factory(),
      sizeof(GCVersion));
  CGHappyRollBuyMoney_descriptor_ = file->message_type(13);
  static const int CGHappyRollBuyMoney_offsets_[1] = {
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(CGHappyRollBuyMoney, buymoneynum_),
  };
  CGHappyRollBuyMoney_reflection_ =
    new ::google::protobuf::internal::GeneratedMessageReflection(
      CGHappyRollBuyMoney_descriptor_,
      CGHappyRollBuyMoney::default_instance_,
      CGHappyRollBuyMoney_offsets_,
      GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(CGHappyRollBuyMoney, _has_bits_[0]),
      GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(CGHappyRollBuyMoney, _unknown_fields_),
      -1,
      ::google::protobuf::DescriptorPool::generated_pool(),
      ::google::protobuf::MessageFactory::generated_factory(),
      sizeof(CGHappyRollBuyMoney));
}

namespace {

GOOGLE_PROTOBUF_DECLARE_ONCE(protobuf_AssignDescriptors_once_);
inline void protobuf_AssignDescriptorsOnce() {
  ::google::protobuf::GoogleOnceInit(&protobuf_AssignDescriptors_once_,
                 &protobuf_AssignDesc_HappyRollMessage_2eproto);
}

void protobuf_RegisterTypes(const ::std::string&) {
  protobuf_AssignDescriptorsOnce();
  ::google::protobuf::MessageFactory::InternalRegisterGeneratedMessage(
    HRRewardInfo_descriptor_, &HRRewardInfo::default_instance());
  ::google::protobuf::MessageFactory::InternalRegisterGeneratedMessage(
    ShowInfo_descriptor_, &ShowInfo::default_instance());
  ::google::protobuf::MessageFactory::InternalRegisterGeneratedMessage(
    HRInfo_descriptor_, &HRInfo::default_instance());
  ::google::protobuf::MessageFactory::InternalRegisterGeneratedMessage(
    CGHappyRoll_descriptor_, &CGHappyRoll::default_instance());
  ::google::protobuf::MessageFactory::InternalRegisterGeneratedMessage(
    GCHappyRoll_descriptor_, &GCHappyRoll::default_instance());
  ::google::protobuf::MessageFactory::InternalRegisterGeneratedMessage(
    GCHappyRollRewardList_descriptor_, &GCHappyRollRewardList::default_instance());
  ::google::protobuf::MessageFactory::InternalRegisterGeneratedMessage(
    GCHappyRollJackPotList_descriptor_, &GCHappyRollJackPotList::default_instance());
  ::google::protobuf::MessageFactory::InternalRegisterGeneratedMessage(
    CGLottery_descriptor_, &CGLottery::default_instance());
  ::google::protobuf::MessageFactory::InternalRegisterGeneratedMessage(
    GCLottery_descriptor_, &GCLottery::default_instance());
  ::google::protobuf::MessageFactory::InternalRegisterGeneratedMessage(
    CGHappyRollGetReward_descriptor_, &CGHappyRollGetReward::default_instance());
  ::google::protobuf::MessageFactory::InternalRegisterGeneratedMessage(
    GCHappyRollGetRewardBack_descriptor_, &GCHappyRollGetRewardBack::default_instance());
  ::google::protobuf::MessageFactory::InternalRegisterGeneratedMessage(
    CGCheckHRUpdate_descriptor_, &CGCheckHRUpdate::default_instance());
  ::google::protobuf::MessageFactory::InternalRegisterGeneratedMessage(
    GCVersion_descriptor_, &GCVersion::default_instance());
  ::google::protobuf::MessageFactory::InternalRegisterGeneratedMessage(
    CGHappyRollBuyMoney_descriptor_, &CGHappyRollBuyMoney::default_instance());
}

}  // namespace

void protobuf_ShutdownFile_HappyRollMessage_2eproto() {
  delete HRRewardInfo::default_instance_;
  delete HRRewardInfo_reflection_;
  delete ShowInfo::default_instance_;
  delete ShowInfo_reflection_;
  delete HRInfo::default_instance_;
  delete HRInfo_reflection_;
  delete CGHappyRoll::default_instance_;
  delete CGHappyRoll_reflection_;
  delete GCHappyRoll::default_instance_;
  delete GCHappyRoll_reflection_;
  delete GCHappyRollRewardList::default_instance_;
  delete GCHappyRollRewardList_reflection_;
  delete GCHappyRollJackPotList::default_instance_;
  delete GCHappyRollJackPotList_reflection_;
  delete CGLottery::default_instance_;
  delete CGLottery_reflection_;
  delete GCLottery::default_instance_;
  delete GCLottery_reflection_;
  delete CGHappyRollGetReward::default_instance_;
  delete CGHappyRollGetReward_reflection_;
  delete GCHappyRollGetRewardBack::default_instance_;
  delete GCHappyRollGetRewardBack_reflection_;
  delete CGCheckHRUpdate::default_instance_;
  delete CGCheckHRUpdate_reflection_;
  delete GCVersion::default_instance_;
  delete GCVersion_reflection_;
  delete CGHappyRollBuyMoney::default_instance_;
  delete CGHappyRollBuyMoney_reflection_;
}

void protobuf_AddDesc_HappyRollMessage_2eproto() {
  static bool already_here = false;
  if (already_here) return;
  already_here = true;
  GOOGLE_PROTOBUF_VERIFY_VERSION;

  ::protobuf_AddDesc_InnerMessage_2eproto();
  ::google::protobuf::DescriptorPool::InternalAddGeneratedFile(
    "\n\026HappyRollMessage.proto\032\022InnerMessage.p"
    "roto\"\205\001\n\014HRRewardInfo\022\033\n\010itemInfo\030\001 \003(\0132"
    "\t.Iteminfo\022\022\n\nconsumeBid\030\002 \001(\005\022\022\n\nconsum"
    "eSid\030\003 \001(\005\022\024\n\014consumeValue\030\004 \001(\005\022\016\n\006isSh"
    "ow\030\005 \001(\005\022\n\n\002id\030\006 \001(\005\"#\n\010ShowInfo\022\n\n\002id\030\001"
    " \001(\005\022\013\n\003num\030\002 \001(\005\"\267\001\n\006HRInfo\022\022\n\nrewardLi"
    "st\030\001 \003(\t\022\021\n\tstartTime\030\002 \001(\003\022\017\n\007endTime\030\003"
    " \001(\003\022\024\n\014jackPotScore\030\004 \001(\005\022\024\n\014jackPotMon"
    "ey\030\005 \001(\005\022\017\n\007percent\030\006 \001(\005\022\020\n\010integral\030\007 "
    "\001(\005\022\024\n\014maxSelectNum\030\010 \001(\005\022\020\n\010lastPond\030\t "
    "\001(\005\"\033\n\013CGHappyRoll\022\014\n\004type\030\001 \001(\005\"J\n\013GCHa"
    "ppyRoll\022\014\n\004type\030\001 \001(\005\022\027\n\006hrInfo\030\002 \001(\0132\007."
    "HRInfo\022\024\n\014haveMoneyNum\030\003 \001(\005\"e\n\025GCHappyR"
    "ollRewardList\022#\n\014hrRewardList\030\001 \003(\0132\r.HR"
    "RewardInfo\022\021\n\thrMulList\030\002 \003(\005\022\024\n\014hrMulDe"
    "sList\030\003 \003(\005\"2\n\026GCHappyRollJackPotList\022\030\n"
    "\005shows\030\001 \003(\0132\t.ShowInfo\"=\n\tCGLottery\022\031\n\021"
    "choseRewardIDList\030\001 \003(\005\022\025\n\rchoseMultiple"
    "\030\002 \001(\005\"\?\n\tGCLottery\022\016\n\006result\030\001 \001(\005\022\020\n\010t"
    "argetID\030\002 \001(\005\022\020\n\010integral\030\003 \001(\005\"\026\n\024CGHap"
    "pyRollGetReward\"*\n\030GCHappyRollGetRewardB"
    "ack\022\016\n\006result\030\001 \001(\005\"\021\n\017CGCheckHRUpdate\"\034"
    "\n\tGCVersion\022\017\n\007version\030\001 \001(\005\"*\n\023CGHappyR"
    "ollBuyMoney\022\023\n\013buyMoneyNum\030\001 \001(\005B\031\n\027com."
    "mile.common.message", 979);
  ::google::protobuf::MessageFactory::InternalRegisterGeneratedFile(
    "HappyRollMessage.proto", &protobuf_RegisterTypes);
  HRRewardInfo::default_instance_ = new HRRewardInfo();
  ShowInfo::default_instance_ = new ShowInfo();
  HRInfo::default_instance_ = new HRInfo();
  CGHappyRoll::default_instance_ = new CGHappyRoll();
  GCHappyRoll::default_instance_ = new GCHappyRoll();
  GCHappyRollRewardList::default_instance_ = new GCHappyRollRewardList();
  GCHappyRollJackPotList::default_instance_ = new GCHappyRollJackPotList();
  CGLottery::default_instance_ = new CGLottery();
  GCLottery::default_instance_ = new GCLottery();
  CGHappyRollGetReward::default_instance_ = new CGHappyRollGetReward();
  GCHappyRollGetRewardBack::default_instance_ = new GCHappyRollGetRewardBack();
  CGCheckHRUpdate::default_instance_ = new CGCheckHRUpdate();
  GCVersion::default_instance_ = new GCVersion();
  CGHappyRollBuyMoney::default_instance_ = new CGHappyRollBuyMoney();
  HRRewardInfo::default_instance_->InitAsDefaultInstance();
  ShowInfo::default_instance_->InitAsDefaultInstance();
  HRInfo::default_instance_->InitAsDefaultInstance();
  CGHappyRoll::default_instance_->InitAsDefaultInstance();
  GCHappyRoll::default_instance_->InitAsDefaultInstance();
  GCHappyRollRewardList::default_instance_->InitAsDefaultInstance();
  GCHappyRollJackPotList::default_instance_->InitAsDefaultInstance();
  CGLottery::default_instance_->InitAsDefaultInstance();
  GCLottery::default_instance_->InitAsDefaultInstance();
  CGHappyRollGetReward::default_instance_->InitAsDefaultInstance();
  GCHappyRollGetRewardBack::default_instance_->InitAsDefaultInstance();
  CGCheckHRUpdate::default_instance_->InitAsDefaultInstance();
  GCVersion::default_instance_->InitAsDefaultInstance();
  CGHappyRollBuyMoney::default_instance_->InitAsDefaultInstance();
  ::google::protobuf::internal::OnShutdown(&protobuf_ShutdownFile_HappyRollMessage_2eproto);
}

// Force AddDescriptors() to be called at static initialization time.
struct StaticDescriptorInitializer_HappyRollMessage_2eproto {
  StaticDescriptorInitializer_HappyRollMessage_2eproto() {
    protobuf_AddDesc_HappyRollMessage_2eproto();
  }
} static_descriptor_initializer_HappyRollMessage_2eproto_;

// ===================================================================

#ifndef _MSC_VER
const int HRRewardInfo::kItemInfoFieldNumber;
const int HRRewardInfo::kConsumeBidFieldNumber;
const int HRRewardInfo::kConsumeSidFieldNumber;
const int HRRewardInfo::kConsumeValueFieldNumber;
const int HRRewardInfo::kIsShowFieldNumber;
const int HRRewardInfo::kIdFieldNumber;
#endif  // !_MSC_VER

HRRewardInfo::HRRewardInfo()
  : ::google::protobuf::Message() {
  SharedCtor();
  // @@protoc_insertion_point(constructor:HRRewardInfo)
}

void HRRewardInfo::InitAsDefaultInstance() {
}

HRRewardInfo::HRRewardInfo(const HRRewardInfo& from)
  : ::google::protobuf::Message() {
  SharedCtor();
  MergeFrom(from);
  // @@protoc_insertion_point(copy_constructor:HRRewardInfo)
}

void HRRewardInfo::SharedCtor() {
  _cached_size_ = 0;
  consumebid_ = 0;
  consumesid_ = 0;
  consumevalue_ = 0;
  isshow_ = 0;
  id_ = 0;
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

HRRewardInfo::~HRRewardInfo() {
  // @@protoc_insertion_point(destructor:HRRewardInfo)
  SharedDtor();
}

void HRRewardInfo::SharedDtor() {
  if (this != default_instance_) {
  }
}

void HRRewardInfo::SetCachedSize(int size) const {
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
}
const ::google::protobuf::Descriptor* HRRewardInfo::descriptor() {
  protobuf_AssignDescriptorsOnce();
  return HRRewardInfo_descriptor_;
}

const HRRewardInfo& HRRewardInfo::default_instance() {
  if (default_instance_ == NULL) protobuf_AddDesc_HappyRollMessage_2eproto();
  return *default_instance_;
}

HRRewardInfo* HRRewardInfo::default_instance_ = NULL;

HRRewardInfo* HRRewardInfo::New() const {
  return new HRRewardInfo;
}

void HRRewardInfo::Clear() {
#define OFFSET_OF_FIELD_(f) (reinterpret_cast<char*>(      \
  &reinterpret_cast<HRRewardInfo*>(16)->f) - \
   reinterpret_cast<char*>(16))

#define ZR_(first, last) do {                              \
    size_t f = OFFSET_OF_FIELD_(first);                    \
    size_t n = OFFSET_OF_FIELD_(last) - f + sizeof(last);  \
    ::memset(&first, 0, n);                                \
  } while (0)

  if (_has_bits_[0 / 32] & 62) {
    ZR_(consumebid_, id_);
  }

#undef OFFSET_OF_FIELD_
#undef ZR_

  iteminfo_.Clear();
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
  mutable_unknown_fields()->Clear();
}

bool HRRewardInfo::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!(EXPRESSION)) goto failure
  ::google::protobuf::uint32 tag;
  // @@protoc_insertion_point(parse_start:HRRewardInfo)
  for (;;) {
    ::std::pair< ::google::protobuf::uint32, bool> p = input->ReadTagWithCutoff(127);
    tag = p.first;
    if (!p.second) goto handle_unusual;
    switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // repeated .Iteminfo itemInfo = 1;
      case 1: {
        if (tag == 10) {
         parse_itemInfo:
          DO_(::google::protobuf::internal::WireFormatLite::ReadMessageNoVirtual(
                input, add_iteminfo()));
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(10)) goto parse_itemInfo;
        if (input->ExpectTag(16)) goto parse_consumeBid;
        break;
      }

      // optional int32 consumeBid = 2;
      case 2: {
        if (tag == 16) {
         parse_consumeBid:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::int32, ::google::protobuf::internal::WireFormatLite::TYPE_INT32>(
                 input, &consumebid_)));
          set_has_consumebid();
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(24)) goto parse_consumeSid;
        break;
      }

      // optional int32 consumeSid = 3;
      case 3: {
        if (tag == 24) {
         parse_consumeSid:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::int32, ::google::protobuf::internal::WireFormatLite::TYPE_INT32>(
                 input, &consumesid_)));
          set_has_consumesid();
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(32)) goto parse_consumeValue;
        break;
      }

      // optional int32 consumeValue = 4;
      case 4: {
        if (tag == 32) {
         parse_consumeValue:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::int32, ::google::protobuf::internal::WireFormatLite::TYPE_INT32>(
                 input, &consumevalue_)));
          set_has_consumevalue();
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(40)) goto parse_isShow;
        break;
      }

      // optional int32 isShow = 5;
      case 5: {
        if (tag == 40) {
         parse_isShow:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::int32, ::google::protobuf::internal::WireFormatLite::TYPE_INT32>(
                 input, &isshow_)));
          set_has_isshow();
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(48)) goto parse_id;
        break;
      }

      // optional int32 id = 6;
      case 6: {
        if (tag == 48) {
         parse_id:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::int32, ::google::protobuf::internal::WireFormatLite::TYPE_INT32>(
                 input, &id_)));
          set_has_id();
        } else {
          goto handle_unusual;
        }
        if (input->ExpectAtEnd()) goto success;
        break;
      }

      default: {
      handle_unusual:
        if (tag == 0 ||
            ::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_END_GROUP) {
          goto success;
        }
        DO_(::google::protobuf::internal::WireFormat::SkipField(
              input, tag, mutable_unknown_fields()));
        break;
      }
    }
  }
success:
  // @@protoc_insertion_point(parse_success:HRRewardInfo)
  return true;
failure:
  // @@protoc_insertion_point(parse_failure:HRRewardInfo)
  return false;
#undef DO_
}

void HRRewardInfo::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // @@protoc_insertion_point(serialize_start:HRRewardInfo)
  // repeated .Iteminfo itemInfo = 1;
  for (int i = 0; i < this->iteminfo_size(); i++) {
    ::google::protobuf::internal::WireFormatLite::WriteMessageMaybeToArray(
      1, this->iteminfo(i), output);
  }

  // optional int32 consumeBid = 2;
  if (has_consumebid()) {
    ::google::protobuf::internal::WireFormatLite::WriteInt32(2, this->consumebid(), output);
  }

  // optional int32 consumeSid = 3;
  if (has_consumesid()) {
    ::google::protobuf::internal::WireFormatLite::WriteInt32(3, this->consumesid(), output);
  }

  // optional int32 consumeValue = 4;
  if (has_consumevalue()) {
    ::google::protobuf::internal::WireFormatLite::WriteInt32(4, this->consumevalue(), output);
  }

  // optional int32 isShow = 5;
  if (has_isshow()) {
    ::google::protobuf::internal::WireFormatLite::WriteInt32(5, this->isshow(), output);
  }

  // optional int32 id = 6;
  if (has_id()) {
    ::google::protobuf::internal::WireFormatLite::WriteInt32(6, this->id(), output);
  }

  if (!unknown_fields().empty()) {
    ::google::protobuf::internal::WireFormat::SerializeUnknownFields(
        unknown_fields(), output);
  }
  // @@protoc_insertion_point(serialize_end:HRRewardInfo)
}

::google::protobuf::uint8* HRRewardInfo::SerializeWithCachedSizesToArray(
    ::google::protobuf::uint8* target) const {
  // @@protoc_insertion_point(serialize_to_array_start:HRRewardInfo)
  // repeated .Iteminfo itemInfo = 1;
  for (int i = 0; i < this->iteminfo_size(); i++) {
    target = ::google::protobuf::internal::WireFormatLite::
      WriteMessageNoVirtualToArray(
        1, this->iteminfo(i), target);
  }

  // optional int32 consumeBid = 2;
  if (has_consumebid()) {
    target = ::google::protobuf::internal::WireFormatLite::WriteInt32ToArray(2, this->consumebid(), target);
  }

  // optional int32 consumeSid = 3;
  if (has_consumesid()) {
    target = ::google::protobuf::internal::WireFormatLite::WriteInt32ToArray(3, this->consumesid(), target);
  }

  // optional int32 consumeValue = 4;
  if (has_consumevalue()) {
    target = ::google::protobuf::internal::WireFormatLite::WriteInt32ToArray(4, this->consumevalue(), target);
  }

  // optional int32 isShow = 5;
  if (has_isshow()) {
    target = ::google::protobuf::internal::WireFormatLite::WriteInt32ToArray(5, this->isshow(), target);
  }

  // optional int32 id = 6;
  if (has_id()) {
    target = ::google::protobuf::internal::WireFormatLite::WriteInt32ToArray(6, this->id(), target);
  }

  if (!unknown_fields().empty()) {
    target = ::google::protobuf::internal::WireFormat::SerializeUnknownFieldsToArray(
        unknown_fields(), target);
  }
  // @@protoc_insertion_point(serialize_to_array_end:HRRewardInfo)
  return target;
}

int HRRewardInfo::ByteSize() const {
  int total_size = 0;

  if (_has_bits_[1 / 32] & (0xffu << (1 % 32))) {
    // optional int32 consumeBid = 2;
    if (has_consumebid()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::Int32Size(
          this->consumebid());
    }

    // optional int32 consumeSid = 3;
    if (has_consumesid()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::Int32Size(
          this->consumesid());
    }

    // optional int32 consumeValue = 4;
    if (has_consumevalue()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::Int32Size(
          this->consumevalue());
    }

    // optional int32 isShow = 5;
    if (has_isshow()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::Int32Size(
          this->isshow());
    }

    // optional int32 id = 6;
    if (has_id()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::Int32Size(
          this->id());
    }

  }
  // repeated .Iteminfo itemInfo = 1;
  total_size += 1 * this->iteminfo_size();
  for (int i = 0; i < this->iteminfo_size(); i++) {
    total_size +=
      ::google::protobuf::internal::WireFormatLite::MessageSizeNoVirtual(
        this->iteminfo(i));
  }

  if (!unknown_fields().empty()) {
    total_size +=
      ::google::protobuf::internal::WireFormat::ComputeUnknownFieldsSize(
        unknown_fields());
  }
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = total_size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
  return total_size;
}

void HRRewardInfo::MergeFrom(const ::google::protobuf::Message& from) {
  GOOGLE_CHECK_NE(&from, this);
  const HRRewardInfo* source =
    ::google::protobuf::internal::dynamic_cast_if_available<const HRRewardInfo*>(
      &from);
  if (source == NULL) {
    ::google::protobuf::internal::ReflectionOps::Merge(from, this);
  } else {
    MergeFrom(*source);
  }
}

void HRRewardInfo::MergeFrom(const HRRewardInfo& from) {
  GOOGLE_CHECK_NE(&from, this);
  iteminfo_.MergeFrom(from.iteminfo_);
  if (from._has_bits_[1 / 32] & (0xffu << (1 % 32))) {
    if (from.has_consumebid()) {
      set_consumebid(from.consumebid());
    }
    if (from.has_consumesid()) {
      set_consumesid(from.consumesid());
    }
    if (from.has_consumevalue()) {
      set_consumevalue(from.consumevalue());
    }
    if (from.has_isshow()) {
      set_isshow(from.isshow());
    }
    if (from.has_id()) {
      set_id(from.id());
    }
  }
  mutable_unknown_fields()->MergeFrom(from.unknown_fields());
}

void HRRewardInfo::CopyFrom(const ::google::protobuf::Message& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

void HRRewardInfo::CopyFrom(const HRRewardInfo& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool HRRewardInfo::IsInitialized() const {

  return true;
}

void HRRewardInfo::Swap(HRRewardInfo* other) {
  if (other != this) {
    iteminfo_.Swap(&other->iteminfo_);
    std::swap(consumebid_, other->consumebid_);
    std::swap(consumesid_, other->consumesid_);
    std::swap(consumevalue_, other->consumevalue_);
    std::swap(isshow_, other->isshow_);
    std::swap(id_, other->id_);
    std::swap(_has_bits_[0], other->_has_bits_[0]);
    _unknown_fields_.Swap(&other->_unknown_fields_);
    std::swap(_cached_size_, other->_cached_size_);
  }
}

::google::protobuf::Metadata HRRewardInfo::GetMetadata() const {
  protobuf_AssignDescriptorsOnce();
  ::google::protobuf::Metadata metadata;
  metadata.descriptor = HRRewardInfo_descriptor_;
  metadata.reflection = HRRewardInfo_reflection_;
  return metadata;
}


// ===================================================================

#ifndef _MSC_VER
const int ShowInfo::kIdFieldNumber;
const int ShowInfo::kNumFieldNumber;
#endif  // !_MSC_VER

ShowInfo::ShowInfo()
  : ::google::protobuf::Message() {
  SharedCtor();
  // @@protoc_insertion_point(constructor:ShowInfo)
}

void ShowInfo::InitAsDefaultInstance() {
}

ShowInfo::ShowInfo(const ShowInfo& from)
  : ::google::protobuf::Message() {
  SharedCtor();
  MergeFrom(from);
  // @@protoc_insertion_point(copy_constructor:ShowInfo)
}

void ShowInfo::SharedCtor() {
  _cached_size_ = 0;
  id_ = 0;
  num_ = 0;
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

ShowInfo::~ShowInfo() {
  // @@protoc_insertion_point(destructor:ShowInfo)
  SharedDtor();
}

void ShowInfo::SharedDtor() {
  if (this != default_instance_) {
  }
}

void ShowInfo::SetCachedSize(int size) const {
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
}
const ::google::protobuf::Descriptor* ShowInfo::descriptor() {
  protobuf_AssignDescriptorsOnce();
  return ShowInfo_descriptor_;
}

const ShowInfo& ShowInfo::default_instance() {
  if (default_instance_ == NULL) protobuf_AddDesc_HappyRollMessage_2eproto();
  return *default_instance_;
}

ShowInfo* ShowInfo::default_instance_ = NULL;

ShowInfo* ShowInfo::New() const {
  return new ShowInfo;
}

void ShowInfo::Clear() {
#define OFFSET_OF_FIELD_(f) (reinterpret_cast<char*>(      \
  &reinterpret_cast<ShowInfo*>(16)->f) - \
   reinterpret_cast<char*>(16))

#define ZR_(first, last) do {                              \
    size_t f = OFFSET_OF_FIELD_(first);                    \
    size_t n = OFFSET_OF_FIELD_(last) - f + sizeof(last);  \
    ::memset(&first, 0, n);                                \
  } while (0)

  ZR_(id_, num_);

#undef OFFSET_OF_FIELD_
#undef ZR_

  ::memset(_has_bits_, 0, sizeof(_has_bits_));
  mutable_unknown_fields()->Clear();
}

bool ShowInfo::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!(EXPRESSION)) goto failure
  ::google::protobuf::uint32 tag;
  // @@protoc_insertion_point(parse_start:ShowInfo)
  for (;;) {
    ::std::pair< ::google::protobuf::uint32, bool> p = input->ReadTagWithCutoff(127);
    tag = p.first;
    if (!p.second) goto handle_unusual;
    switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // optional int32 id = 1;
      case 1: {
        if (tag == 8) {
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::int32, ::google::protobuf::internal::WireFormatLite::TYPE_INT32>(
                 input, &id_)));
          set_has_id();
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(16)) goto parse_num;
        break;
      }

      // optional int32 num = 2;
      case 2: {
        if (tag == 16) {
         parse_num:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::int32, ::google::protobuf::internal::WireFormatLite::TYPE_INT32>(
                 input, &num_)));
          set_has_num();
        } else {
          goto handle_unusual;
        }
        if (input->ExpectAtEnd()) goto success;
        break;
      }

      default: {
      handle_unusual:
        if (tag == 0 ||
            ::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_END_GROUP) {
          goto success;
        }
        DO_(::google::protobuf::internal::WireFormat::SkipField(
              input, tag, mutable_unknown_fields()));
        break;
      }
    }
  }
success:
  // @@protoc_insertion_point(parse_success:ShowInfo)
  return true;
failure:
  // @@protoc_insertion_point(parse_failure:ShowInfo)
  return false;
#undef DO_
}

void ShowInfo::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // @@protoc_insertion_point(serialize_start:ShowInfo)
  // optional int32 id = 1;
  if (has_id()) {
    ::google::protobuf::internal::WireFormatLite::WriteInt32(1, this->id(), output);
  }

  // optional int32 num = 2;
  if (has_num()) {
    ::google::protobuf::internal::WireFormatLite::WriteInt32(2, this->num(), output);
  }

  if (!unknown_fields().empty()) {
    ::google::protobuf::internal::WireFormat::SerializeUnknownFields(
        unknown_fields(), output);
  }
  // @@protoc_insertion_point(serialize_end:ShowInfo)
}

::google::protobuf::uint8* ShowInfo::SerializeWithCachedSizesToArray(
    ::google::protobuf::uint8* target) const {
  // @@protoc_insertion_point(serialize_to_array_start:ShowInfo)
  // optional int32 id = 1;
  if (has_id()) {
    target = ::google::protobuf::internal::WireFormatLite::WriteInt32ToArray(1, this->id(), target);
  }

  // optional int32 num = 2;
  if (has_num()) {
    target = ::google::protobuf::internal::WireFormatLite::WriteInt32ToArray(2, this->num(), target);
  }

  if (!unknown_fields().empty()) {
    target = ::google::protobuf::internal::WireFormat::SerializeUnknownFieldsToArray(
        unknown_fields(), target);
  }
  // @@protoc_insertion_point(serialize_to_array_end:ShowInfo)
  return target;
}

int ShowInfo::ByteSize() const {
  int total_size = 0;

  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    // optional int32 id = 1;
    if (has_id()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::Int32Size(
          this->id());
    }

    // optional int32 num = 2;
    if (has_num()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::Int32Size(
          this->num());
    }

  }
  if (!unknown_fields().empty()) {
    total_size +=
      ::google::protobuf::internal::WireFormat::ComputeUnknownFieldsSize(
        unknown_fields());
  }
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = total_size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
  return total_size;
}

void ShowInfo::MergeFrom(const ::google::protobuf::Message& from) {
  GOOGLE_CHECK_NE(&from, this);
  const ShowInfo* source =
    ::google::protobuf::internal::dynamic_cast_if_available<const ShowInfo*>(
      &from);
  if (source == NULL) {
    ::google::protobuf::internal::ReflectionOps::Merge(from, this);
  } else {
    MergeFrom(*source);
  }
}

void ShowInfo::MergeFrom(const ShowInfo& from) {
  GOOGLE_CHECK_NE(&from, this);
  if (from._has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    if (from.has_id()) {
      set_id(from.id());
    }
    if (from.has_num()) {
      set_num(from.num());
    }
  }
  mutable_unknown_fields()->MergeFrom(from.unknown_fields());
}

void ShowInfo::CopyFrom(const ::google::protobuf::Message& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

void ShowInfo::CopyFrom(const ShowInfo& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool ShowInfo::IsInitialized() const {

  return true;
}

void ShowInfo::Swap(ShowInfo* other) {
  if (other != this) {
    std::swap(id_, other->id_);
    std::swap(num_, other->num_);
    std::swap(_has_bits_[0], other->_has_bits_[0]);
    _unknown_fields_.Swap(&other->_unknown_fields_);
    std::swap(_cached_size_, other->_cached_size_);
  }
}

::google::protobuf::Metadata ShowInfo::GetMetadata() const {
  protobuf_AssignDescriptorsOnce();
  ::google::protobuf::Metadata metadata;
  metadata.descriptor = ShowInfo_descriptor_;
  metadata.reflection = ShowInfo_reflection_;
  return metadata;
}


// ===================================================================

#ifndef _MSC_VER
const int HRInfo::kRewardListFieldNumber;
const int HRInfo::kStartTimeFieldNumber;
const int HRInfo::kEndTimeFieldNumber;
const int HRInfo::kJackPotScoreFieldNumber;
const int HRInfo::kJackPotMoneyFieldNumber;
const int HRInfo::kPercentFieldNumber;
const int HRInfo::kIntegralFieldNumber;
const int HRInfo::kMaxSelectNumFieldNumber;
const int HRInfo::kLastPondFieldNumber;
#endif  // !_MSC_VER

HRInfo::HRInfo()
  : ::google::protobuf::Message() {
  SharedCtor();
  // @@protoc_insertion_point(constructor:HRInfo)
}

void HRInfo::InitAsDefaultInstance() {
}

HRInfo::HRInfo(const HRInfo& from)
  : ::google::protobuf::Message() {
  SharedCtor();
  MergeFrom(from);
  // @@protoc_insertion_point(copy_constructor:HRInfo)
}

void HRInfo::SharedCtor() {
  ::google::protobuf::internal::GetEmptyString();
  _cached_size_ = 0;
  starttime_ = GOOGLE_LONGLONG(0);
  endtime_ = GOOGLE_LONGLONG(0);
  jackpotscore_ = 0;
  jackpotmoney_ = 0;
  percent_ = 0;
  integral_ = 0;
  maxselectnum_ = 0;
  lastpond_ = 0;
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

HRInfo::~HRInfo() {
  // @@protoc_insertion_point(destructor:HRInfo)
  SharedDtor();
}

void HRInfo::SharedDtor() {
  if (this != default_instance_) {
  }
}

void HRInfo::SetCachedSize(int size) const {
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
}
const ::google::protobuf::Descriptor* HRInfo::descriptor() {
  protobuf_AssignDescriptorsOnce();
  return HRInfo_descriptor_;
}

const HRInfo& HRInfo::default_instance() {
  if (default_instance_ == NULL) protobuf_AddDesc_HappyRollMessage_2eproto();
  return *default_instance_;
}

HRInfo* HRInfo::default_instance_ = NULL;

HRInfo* HRInfo::New() const {
  return new HRInfo;
}

void HRInfo::Clear() {
#define OFFSET_OF_FIELD_(f) (reinterpret_cast<char*>(      \
  &reinterpret_cast<HRInfo*>(16)->f) - \
   reinterpret_cast<char*>(16))

#define ZR_(first, last) do {                              \
    size_t f = OFFSET_OF_FIELD_(first);                    \
    size_t n = OFFSET_OF_FIELD_(last) - f + sizeof(last);  \
    ::memset(&first, 0, n);                                \
  } while (0)

  if (_has_bits_[0 / 32] & 254) {
    ZR_(starttime_, maxselectnum_);
  }
  lastpond_ = 0;

#undef OFFSET_OF_FIELD_
#undef ZR_

  rewardlist_.Clear();
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
  mutable_unknown_fields()->Clear();
}

bool HRInfo::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!(EXPRESSION)) goto failure
  ::google::protobuf::uint32 tag;
  // @@protoc_insertion_point(parse_start:HRInfo)
  for (;;) {
    ::std::pair< ::google::protobuf::uint32, bool> p = input->ReadTagWithCutoff(127);
    tag = p.first;
    if (!p.second) goto handle_unusual;
    switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // repeated string rewardList = 1;
      case 1: {
        if (tag == 10) {
         parse_rewardList:
          DO_(::google::protobuf::internal::WireFormatLite::ReadString(
                input, this->add_rewardlist()));
          ::google::protobuf::internal::WireFormat::VerifyUTF8StringNamedField(
            this->rewardlist(this->rewardlist_size() - 1).data(),
            this->rewardlist(this->rewardlist_size() - 1).length(),
            ::google::protobuf::internal::WireFormat::PARSE,
            "rewardlist");
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(10)) goto parse_rewardList;
        if (input->ExpectTag(16)) goto parse_startTime;
        break;
      }

      // optional int64 startTime = 2;
      case 2: {
        if (tag == 16) {
         parse_startTime:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::int64, ::google::protobuf::internal::WireFormatLite::TYPE_INT64>(
                 input, &starttime_)));
          set_has_starttime();
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(24)) goto parse_endTime;
        break;
      }

      // optional int64 endTime = 3;
      case 3: {
        if (tag == 24) {
         parse_endTime:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::int64, ::google::protobuf::internal::WireFormatLite::TYPE_INT64>(
                 input, &endtime_)));
          set_has_endtime();
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(32)) goto parse_jackPotScore;
        break;
      }

      // optional int32 jackPotScore = 4;
      case 4: {
        if (tag == 32) {
         parse_jackPotScore:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::int32, ::google::protobuf::internal::WireFormatLite::TYPE_INT32>(
                 input, &jackpotscore_)));
          set_has_jackpotscore();
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(40)) goto parse_jackPotMoney;
        break;
      }

      // optional int32 jackPotMoney = 5;
      case 5: {
        if (tag == 40) {
         parse_jackPotMoney:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::int32, ::google::protobuf::internal::WireFormatLite::TYPE_INT32>(
                 input, &jackpotmoney_)));
          set_has_jackpotmoney();
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(48)) goto parse_percent;
        break;
      }

      // optional int32 percent = 6;
      case 6: {
        if (tag == 48) {
         parse_percent:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::int32, ::google::protobuf::internal::WireFormatLite::TYPE_INT32>(
                 input, &percent_)));
          set_has_percent();
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(56)) goto parse_integral;
        break;
      }

      // optional int32 integral = 7;
      case 7: {
        if (tag == 56) {
         parse_integral:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::int32, ::google::protobuf::internal::WireFormatLite::TYPE_INT32>(
                 input, &integral_)));
          set_has_integral();
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(64)) goto parse_maxSelectNum;
        break;
      }

      // optional int32 maxSelectNum = 8;
      case 8: {
        if (tag == 64) {
         parse_maxSelectNum:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::int32, ::google::protobuf::internal::WireFormatLite::TYPE_INT32>(
                 input, &maxselectnum_)));
          set_has_maxselectnum();
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(72)) goto parse_lastPond;
        break;
      }

      // optional int32 lastPond = 9;
      case 9: {
        if (tag == 72) {
         parse_lastPond:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::int32, ::google::protobuf::internal::WireFormatLite::TYPE_INT32>(
                 input, &lastpond_)));
          set_has_lastpond();
        } else {
          goto handle_unusual;
        }
        if (input->ExpectAtEnd()) goto success;
        break;
      }

      default: {
      handle_unusual:
        if (tag == 0 ||
            ::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_END_GROUP) {
          goto success;
        }
        DO_(::google::protobuf::internal::WireFormat::SkipField(
              input, tag, mutable_unknown_fields()));
        break;
      }
    }
  }
success:
  // @@protoc_insertion_point(parse_success:HRInfo)
  return true;
failure:
  // @@protoc_insertion_point(parse_failure:HRInfo)
  return false;
#undef DO_
}

void HRInfo::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // @@protoc_insertion_point(serialize_start:HRInfo)
  // repeated string rewardList = 1;
  for (int i = 0; i < this->rewardlist_size(); i++) {
  ::google::protobuf::internal::WireFormat::VerifyUTF8StringNamedField(
    this->rewardlist(i).data(), this->rewardlist(i).length(),
    ::google::protobuf::internal::WireFormat::SERIALIZE,
    "rewardlist");
    ::google::protobuf::internal::WireFormatLite::WriteString(
      1, this->rewardlist(i), output);
  }

  // optional int64 startTime = 2;
  if (has_starttime()) {
    ::google::protobuf::internal::WireFormatLite::WriteInt64(2, this->starttime(), output);
  }

  // optional int64 endTime = 3;
  if (has_endtime()) {
    ::google::protobuf::internal::WireFormatLite::WriteInt64(3, this->endtime(), output);
  }

  // optional int32 jackPotScore = 4;
  if (has_jackpotscore()) {
    ::google::protobuf::internal::WireFormatLite::WriteInt32(4, this->jackpotscore(), output);
  }

  // optional int32 jackPotMoney = 5;
  if (has_jackpotmoney()) {
    ::google::protobuf::internal::WireFormatLite::WriteInt32(5, this->jackpotmoney(), output);
  }

  // optional int32 percent = 6;
  if (has_percent()) {
    ::google::protobuf::internal::WireFormatLite::WriteInt32(6, this->percent(), output);
  }

  // optional int32 integral = 7;
  if (has_integral()) {
    ::google::protobuf::internal::WireFormatLite::WriteInt32(7, this->integral(), output);
  }

  // optional int32 maxSelectNum = 8;
  if (has_maxselectnum()) {
    ::google::protobuf::internal::WireFormatLite::WriteInt32(8, this->maxselectnum(), output);
  }

  // optional int32 lastPond = 9;
  if (has_lastpond()) {
    ::google::protobuf::internal::WireFormatLite::WriteInt32(9, this->lastpond(), output);
  }

  if (!unknown_fields().empty()) {
    ::google::protobuf::internal::WireFormat::SerializeUnknownFields(
        unknown_fields(), output);
  }
  // @@protoc_insertion_point(serialize_end:HRInfo)
}

::google::protobuf::uint8* HRInfo::SerializeWithCachedSizesToArray(
    ::google::protobuf::uint8* target) const {
  // @@protoc_insertion_point(serialize_to_array_start:HRInfo)
  // repeated string rewardList = 1;
  for (int i = 0; i < this->rewardlist_size(); i++) {
    ::google::protobuf::internal::WireFormat::VerifyUTF8StringNamedField(
      this->rewardlist(i).data(), this->rewardlist(i).length(),
      ::google::protobuf::internal::WireFormat::SERIALIZE,
      "rewardlist");
    target = ::google::protobuf::internal::WireFormatLite::
      WriteStringToArray(1, this->rewardlist(i), target);
  }

  // optional int64 startTime = 2;
  if (has_starttime()) {
    target = ::google::protobuf::internal::WireFormatLite::WriteInt64ToArray(2, this->starttime(), target);
  }

  // optional int64 endTime = 3;
  if (has_endtime()) {
    target = ::google::protobuf::internal::WireFormatLite::WriteInt64ToArray(3, this->endtime(), target);
  }

  // optional int32 jackPotScore = 4;
  if (has_jackpotscore()) {
    target = ::google::protobuf::internal::WireFormatLite::WriteInt32ToArray(4, this->jackpotscore(), target);
  }

  // optional int32 jackPotMoney = 5;
  if (has_jackpotmoney()) {
    target = ::google::protobuf::internal::WireFormatLite::WriteInt32ToArray(5, this->jackpotmoney(), target);
  }

  // optional int32 percent = 6;
  if (has_percent()) {
    target = ::google::protobuf::internal::WireFormatLite::WriteInt32ToArray(6, this->percent(), target);
  }

  // optional int32 integral = 7;
  if (has_integral()) {
    target = ::google::protobuf::internal::WireFormatLite::WriteInt32ToArray(7, this->integral(), target);
  }

  // optional int32 maxSelectNum = 8;
  if (has_maxselectnum()) {
    target = ::google::protobuf::internal::WireFormatLite::WriteInt32ToArray(8, this->maxselectnum(), target);
  }

  // optional int32 lastPond = 9;
  if (has_lastpond()) {
    target = ::google::protobuf::internal::WireFormatLite::WriteInt32ToArray(9, this->lastpond(), target);
  }

  if (!unknown_fields().empty()) {
    target = ::google::protobuf::internal::WireFormat::SerializeUnknownFieldsToArray(
        unknown_fields(), target);
  }
  // @@protoc_insertion_point(serialize_to_array_end:HRInfo)
  return target;
}

int HRInfo::ByteSize() const {
  int total_size = 0;

  if (_has_bits_[1 / 32] & (0xffu << (1 % 32))) {
    // optional int64 startTime = 2;
    if (has_starttime()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::Int64Size(
          this->starttime());
    }

    // optional int64 endTime = 3;
    if (has_endtime()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::Int64Size(
          this->endtime());
    }

    // optional int32 jackPotScore = 4;
    if (has_jackpotscore()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::Int32Size(
          this->jackpotscore());
    }

    // optional int32 jackPotMoney = 5;
    if (has_jackpotmoney()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::Int32Size(
          this->jackpotmoney());
    }

    // optional int32 percent = 6;
    if (has_percent()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::Int32Size(
          this->percent());
    }

    // optional int32 integral = 7;
    if (has_integral()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::Int32Size(
          this->integral());
    }

    // optional int32 maxSelectNum = 8;
    if (has_maxselectnum()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::Int32Size(
          this->maxselectnum());
    }

  }
  if (_has_bits_[8 / 32] & (0xffu << (8 % 32))) {
    // optional int32 lastPond = 9;
    if (has_lastpond()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::Int32Size(
          this->lastpond());
    }

  }
  // repeated string rewardList = 1;
  total_size += 1 * this->rewardlist_size();
  for (int i = 0; i < this->rewardlist_size(); i++) {
    total_size += ::google::protobuf::internal::WireFormatLite::StringSize(
      this->rewardlist(i));
  }

  if (!unknown_fields().empty()) {
    total_size +=
      ::google::protobuf::internal::WireFormat::ComputeUnknownFieldsSize(
        unknown_fields());
  }
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = total_size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
  return total_size;
}

void HRInfo::MergeFrom(const ::google::protobuf::Message& from) {
  GOOGLE_CHECK_NE(&from, this);
  const HRInfo* source =
    ::google::protobuf::internal::dynamic_cast_if_available<const HRInfo*>(
      &from);
  if (source == NULL) {
    ::google::protobuf::internal::ReflectionOps::Merge(from, this);
  } else {
    MergeFrom(*source);
  }
}

void HRInfo::MergeFrom(const HRInfo& from) {
  GOOGLE_CHECK_NE(&from, this);
  rewardlist_.MergeFrom(from.rewardlist_);
  if (from._has_bits_[1 / 32] & (0xffu << (1 % 32))) {
    if (from.has_starttime()) {
      set_starttime(from.starttime());
    }
    if (from.has_endtime()) {
      set_endtime(from.endtime());
    }
    if (from.has_jackpotscore()) {
      set_jackpotscore(from.jackpotscore());
    }
    if (from.has_jackpotmoney()) {
      set_jackpotmoney(from.jackpotmoney());
    }
    if (from.has_percent()) {
      set_percent(from.percent());
    }
    if (from.has_integral()) {
      set_integral(from.integral());
    }
    if (from.has_maxselectnum()) {
      set_maxselectnum(from.maxselectnum());
    }
  }
  if (from._has_bits_[8 / 32] & (0xffu << (8 % 32))) {
    if (from.has_lastpond()) {
      set_lastpond(from.lastpond());
    }
  }
  mutable_unknown_fields()->MergeFrom(from.unknown_fields());
}

void HRInfo::CopyFrom(const ::google::protobuf::Message& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

void HRInfo::CopyFrom(const HRInfo& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool HRInfo::IsInitialized() const {

  return true;
}

void HRInfo::Swap(HRInfo* other) {
  if (other != this) {
    rewardlist_.Swap(&other->rewardlist_);
    std::swap(starttime_, other->starttime_);
    std::swap(endtime_, other->endtime_);
    std::swap(jackpotscore_, other->jackpotscore_);
    std::swap(jackpotmoney_, other->jackpotmoney_);
    std::swap(percent_, other->percent_);
    std::swap(integral_, other->integral_);
    std::swap(maxselectnum_, other->maxselectnum_);
    std::swap(lastpond_, other->lastpond_);
    std::swap(_has_bits_[0], other->_has_bits_[0]);
    _unknown_fields_.Swap(&other->_unknown_fields_);
    std::swap(_cached_size_, other->_cached_size_);
  }
}

::google::protobuf::Metadata HRInfo::GetMetadata() const {
  protobuf_AssignDescriptorsOnce();
  ::google::protobuf::Metadata metadata;
  metadata.descriptor = HRInfo_descriptor_;
  metadata.reflection = HRInfo_reflection_;
  return metadata;
}


// ===================================================================

#ifndef _MSC_VER
const int CGHappyRoll::kTypeFieldNumber;
#endif  // !_MSC_VER

CGHappyRoll::CGHappyRoll()
  : ::google::protobuf::Message() {
  SharedCtor();
  // @@protoc_insertion_point(constructor:CGHappyRoll)
}

void CGHappyRoll::InitAsDefaultInstance() {
}

CGHappyRoll::CGHappyRoll(const CGHappyRoll& from)
  : ::google::protobuf::Message() {
  SharedCtor();
  MergeFrom(from);
  // @@protoc_insertion_point(copy_constructor:CGHappyRoll)
}

void CGHappyRoll::SharedCtor() {
  _cached_size_ = 0;
  type_ = 0;
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

CGHappyRoll::~CGHappyRoll() {
  // @@protoc_insertion_point(destructor:CGHappyRoll)
  SharedDtor();
}

void CGHappyRoll::SharedDtor() {
  if (this != default_instance_) {
  }
}

void CGHappyRoll::SetCachedSize(int size) const {
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
}
const ::google::protobuf::Descriptor* CGHappyRoll::descriptor() {
  protobuf_AssignDescriptorsOnce();
  return CGHappyRoll_descriptor_;
}

const CGHappyRoll& CGHappyRoll::default_instance() {
  if (default_instance_ == NULL) protobuf_AddDesc_HappyRollMessage_2eproto();
  return *default_instance_;
}

CGHappyRoll* CGHappyRoll::default_instance_ = NULL;

CGHappyRoll* CGHappyRoll::New() const {
  return new CGHappyRoll;
}

void CGHappyRoll::Clear() {
  type_ = 0;
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
  mutable_unknown_fields()->Clear();
}

bool CGHappyRoll::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!(EXPRESSION)) goto failure
  ::google::protobuf::uint32 tag;
  // @@protoc_insertion_point(parse_start:CGHappyRoll)
  for (;;) {
    ::std::pair< ::google::protobuf::uint32, bool> p = input->ReadTagWithCutoff(127);
    tag = p.first;
    if (!p.second) goto handle_unusual;
    switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // optional int32 type = 1;
      case 1: {
        if (tag == 8) {
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::int32, ::google::protobuf::internal::WireFormatLite::TYPE_INT32>(
                 input, &type_)));
          set_has_type();
        } else {
          goto handle_unusual;
        }
        if (input->ExpectAtEnd()) goto success;
        break;
      }

      default: {
      handle_unusual:
        if (tag == 0 ||
            ::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_END_GROUP) {
          goto success;
        }
        DO_(::google::protobuf::internal::WireFormat::SkipField(
              input, tag, mutable_unknown_fields()));
        break;
      }
    }
  }
success:
  // @@protoc_insertion_point(parse_success:CGHappyRoll)
  return true;
failure:
  // @@protoc_insertion_point(parse_failure:CGHappyRoll)
  return false;
#undef DO_
}

void CGHappyRoll::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // @@protoc_insertion_point(serialize_start:CGHappyRoll)
  // optional int32 type = 1;
  if (has_type()) {
    ::google::protobuf::internal::WireFormatLite::WriteInt32(1, this->type(), output);
  }

  if (!unknown_fields().empty()) {
    ::google::protobuf::internal::WireFormat::SerializeUnknownFields(
        unknown_fields(), output);
  }
  // @@protoc_insertion_point(serialize_end:CGHappyRoll)
}

::google::protobuf::uint8* CGHappyRoll::SerializeWithCachedSizesToArray(
    ::google::protobuf::uint8* target) const {
  // @@protoc_insertion_point(serialize_to_array_start:CGHappyRoll)
  // optional int32 type = 1;
  if (has_type()) {
    target = ::google::protobuf::internal::WireFormatLite::WriteInt32ToArray(1, this->type(), target);
  }

  if (!unknown_fields().empty()) {
    target = ::google::protobuf::internal::WireFormat::SerializeUnknownFieldsToArray(
        unknown_fields(), target);
  }
  // @@protoc_insertion_point(serialize_to_array_end:CGHappyRoll)
  return target;
}

int CGHappyRoll::ByteSize() const {
  int total_size = 0;

  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    // optional int32 type = 1;
    if (has_type()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::Int32Size(
          this->type());
    }

  }
  if (!unknown_fields().empty()) {
    total_size +=
      ::google::protobuf::internal::WireFormat::ComputeUnknownFieldsSize(
        unknown_fields());
  }
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = total_size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
  return total_size;
}

void CGHappyRoll::MergeFrom(const ::google::protobuf::Message& from) {
  GOOGLE_CHECK_NE(&from, this);
  const CGHappyRoll* source =
    ::google::protobuf::internal::dynamic_cast_if_available<const CGHappyRoll*>(
      &from);
  if (source == NULL) {
    ::google::protobuf::internal::ReflectionOps::Merge(from, this);
  } else {
    MergeFrom(*source);
  }
}

void CGHappyRoll::MergeFrom(const CGHappyRoll& from) {
  GOOGLE_CHECK_NE(&from, this);
  if (from._has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    if (from.has_type()) {
      set_type(from.type());
    }
  }
  mutable_unknown_fields()->MergeFrom(from.unknown_fields());
}

void CGHappyRoll::CopyFrom(const ::google::protobuf::Message& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

void CGHappyRoll::CopyFrom(const CGHappyRoll& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool CGHappyRoll::IsInitialized() const {

  return true;
}

void CGHappyRoll::Swap(CGHappyRoll* other) {
  if (other != this) {
    std::swap(type_, other->type_);
    std::swap(_has_bits_[0], other->_has_bits_[0]);
    _unknown_fields_.Swap(&other->_unknown_fields_);
    std::swap(_cached_size_, other->_cached_size_);
  }
}

::google::protobuf::Metadata CGHappyRoll::GetMetadata() const {
  protobuf_AssignDescriptorsOnce();
  ::google::protobuf::Metadata metadata;
  metadata.descriptor = CGHappyRoll_descriptor_;
  metadata.reflection = CGHappyRoll_reflection_;
  return metadata;
}


// ===================================================================

#ifndef _MSC_VER
const int GCHappyRoll::kTypeFieldNumber;
const int GCHappyRoll::kHrInfoFieldNumber;
const int GCHappyRoll::kHaveMoneyNumFieldNumber;
#endif  // !_MSC_VER

GCHappyRoll::GCHappyRoll()
  : ::google::protobuf::Message() {
  SharedCtor();
  // @@protoc_insertion_point(constructor:GCHappyRoll)
}

void GCHappyRoll::InitAsDefaultInstance() {
  hrinfo_ = const_cast< ::HRInfo*>(&::HRInfo::default_instance());
}

GCHappyRoll::GCHappyRoll(const GCHappyRoll& from)
  : ::google::protobuf::Message() {
  SharedCtor();
  MergeFrom(from);
  // @@protoc_insertion_point(copy_constructor:GCHappyRoll)
}

void GCHappyRoll::SharedCtor() {
  _cached_size_ = 0;
  type_ = 0;
  hrinfo_ = NULL;
  havemoneynum_ = 0;
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

GCHappyRoll::~GCHappyRoll() {
  // @@protoc_insertion_point(destructor:GCHappyRoll)
  SharedDtor();
}

void GCHappyRoll::SharedDtor() {
  if (this != default_instance_) {
    delete hrinfo_;
  }
}

void GCHappyRoll::SetCachedSize(int size) const {
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
}
const ::google::protobuf::Descriptor* GCHappyRoll::descriptor() {
  protobuf_AssignDescriptorsOnce();
  return GCHappyRoll_descriptor_;
}

const GCHappyRoll& GCHappyRoll::default_instance() {
  if (default_instance_ == NULL) protobuf_AddDesc_HappyRollMessage_2eproto();
  return *default_instance_;
}

GCHappyRoll* GCHappyRoll::default_instance_ = NULL;

GCHappyRoll* GCHappyRoll::New() const {
  return new GCHappyRoll;
}

void GCHappyRoll::Clear() {
#define OFFSET_OF_FIELD_(f) (reinterpret_cast<char*>(      \
  &reinterpret_cast<GCHappyRoll*>(16)->f) - \
   reinterpret_cast<char*>(16))

#define ZR_(first, last) do {                              \
    size_t f = OFFSET_OF_FIELD_(first);                    \
    size_t n = OFFSET_OF_FIELD_(last) - f + sizeof(last);  \
    ::memset(&first, 0, n);                                \
  } while (0)

  if (_has_bits_[0 / 32] & 7) {
    ZR_(type_, havemoneynum_);
    if (has_hrinfo()) {
      if (hrinfo_ != NULL) hrinfo_->::HRInfo::Clear();
    }
  }

#undef OFFSET_OF_FIELD_
#undef ZR_

  ::memset(_has_bits_, 0, sizeof(_has_bits_));
  mutable_unknown_fields()->Clear();
}

bool GCHappyRoll::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!(EXPRESSION)) goto failure
  ::google::protobuf::uint32 tag;
  // @@protoc_insertion_point(parse_start:GCHappyRoll)
  for (;;) {
    ::std::pair< ::google::protobuf::uint32, bool> p = input->ReadTagWithCutoff(127);
    tag = p.first;
    if (!p.second) goto handle_unusual;
    switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // optional int32 type = 1;
      case 1: {
        if (tag == 8) {
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::int32, ::google::protobuf::internal::WireFormatLite::TYPE_INT32>(
                 input, &type_)));
          set_has_type();
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(18)) goto parse_hrInfo;
        break;
      }

      // optional .HRInfo hrInfo = 2;
      case 2: {
        if (tag == 18) {
         parse_hrInfo:
          DO_(::google::protobuf::internal::WireFormatLite::ReadMessageNoVirtual(
               input, mutable_hrinfo()));
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(24)) goto parse_haveMoneyNum;
        break;
      }

      // optional int32 haveMoneyNum = 3;
      case 3: {
        if (tag == 24) {
         parse_haveMoneyNum:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::int32, ::google::protobuf::internal::WireFormatLite::TYPE_INT32>(
                 input, &havemoneynum_)));
          set_has_havemoneynum();
        } else {
          goto handle_unusual;
        }
        if (input->ExpectAtEnd()) goto success;
        break;
      }

      default: {
      handle_unusual:
        if (tag == 0 ||
            ::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_END_GROUP) {
          goto success;
        }
        DO_(::google::protobuf::internal::WireFormat::SkipField(
              input, tag, mutable_unknown_fields()));
        break;
      }
    }
  }
success:
  // @@protoc_insertion_point(parse_success:GCHappyRoll)
  return true;
failure:
  // @@protoc_insertion_point(parse_failure:GCHappyRoll)
  return false;
#undef DO_
}

void GCHappyRoll::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // @@protoc_insertion_point(serialize_start:GCHappyRoll)
  // optional int32 type = 1;
  if (has_type()) {
    ::google::protobuf::internal::WireFormatLite::WriteInt32(1, this->type(), output);
  }

  // optional .HRInfo hrInfo = 2;
  if (has_hrinfo()) {
    ::google::protobuf::internal::WireFormatLite::WriteMessageMaybeToArray(
      2, this->hrinfo(), output);
  }

  // optional int32 haveMoneyNum = 3;
  if (has_havemoneynum()) {
    ::google::protobuf::internal::WireFormatLite::WriteInt32(3, this->havemoneynum(), output);
  }

  if (!unknown_fields().empty()) {
    ::google::protobuf::internal::WireFormat::SerializeUnknownFields(
        unknown_fields(), output);
  }
  // @@protoc_insertion_point(serialize_end:GCHappyRoll)
}

::google::protobuf::uint8* GCHappyRoll::SerializeWithCachedSizesToArray(
    ::google::protobuf::uint8* target) const {
  // @@protoc_insertion_point(serialize_to_array_start:GCHappyRoll)
  // optional int32 type = 1;
  if (has_type()) {
    target = ::google::protobuf::internal::WireFormatLite::WriteInt32ToArray(1, this->type(), target);
  }

  // optional .HRInfo hrInfo = 2;
  if (has_hrinfo()) {
    target = ::google::protobuf::internal::WireFormatLite::
      WriteMessageNoVirtualToArray(
        2, this->hrinfo(), target);
  }

  // optional int32 haveMoneyNum = 3;
  if (has_havemoneynum()) {
    target = ::google::protobuf::internal::WireFormatLite::WriteInt32ToArray(3, this->havemoneynum(), target);
  }

  if (!unknown_fields().empty()) {
    target = ::google::protobuf::internal::WireFormat::SerializeUnknownFieldsToArray(
        unknown_fields(), target);
  }
  // @@protoc_insertion_point(serialize_to_array_end:GCHappyRoll)
  return target;
}

int GCHappyRoll::ByteSize() const {
  int total_size = 0;

  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    // optional int32 type = 1;
    if (has_type()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::Int32Size(
          this->type());
    }

    // optional .HRInfo hrInfo = 2;
    if (has_hrinfo()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::MessageSizeNoVirtual(
          this->hrinfo());
    }

    // optional int32 haveMoneyNum = 3;
    if (has_havemoneynum()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::Int32Size(
          this->havemoneynum());
    }

  }
  if (!unknown_fields().empty()) {
    total_size +=
      ::google::protobuf::internal::WireFormat::ComputeUnknownFieldsSize(
        unknown_fields());
  }
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = total_size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
  return total_size;
}

void GCHappyRoll::MergeFrom(const ::google::protobuf::Message& from) {
  GOOGLE_CHECK_NE(&from, this);
  const GCHappyRoll* source =
    ::google::protobuf::internal::dynamic_cast_if_available<const GCHappyRoll*>(
      &from);
  if (source == NULL) {
    ::google::protobuf::internal::ReflectionOps::Merge(from, this);
  } else {
    MergeFrom(*source);
  }
}

void GCHappyRoll::MergeFrom(const GCHappyRoll& from) {
  GOOGLE_CHECK_NE(&from, this);
  if (from._has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    if (from.has_type()) {
      set_type(from.type());
    }
    if (from.has_hrinfo()) {
      mutable_hrinfo()->::HRInfo::MergeFrom(from.hrinfo());
    }
    if (from.has_havemoneynum()) {
      set_havemoneynum(from.havemoneynum());
    }
  }
  mutable_unknown_fields()->MergeFrom(from.unknown_fields());
}

void GCHappyRoll::CopyFrom(const ::google::protobuf::Message& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

void GCHappyRoll::CopyFrom(const GCHappyRoll& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool GCHappyRoll::IsInitialized() const {

  return true;
}

void GCHappyRoll::Swap(GCHappyRoll* other) {
  if (other != this) {
    std::swap(type_, other->type_);
    std::swap(hrinfo_, other->hrinfo_);
    std::swap(havemoneynum_, other->havemoneynum_);
    std::swap(_has_bits_[0], other->_has_bits_[0]);
    _unknown_fields_.Swap(&other->_unknown_fields_);
    std::swap(_cached_size_, other->_cached_size_);
  }
}

::google::protobuf::Metadata GCHappyRoll::GetMetadata() const {
  protobuf_AssignDescriptorsOnce();
  ::google::protobuf::Metadata metadata;
  metadata.descriptor = GCHappyRoll_descriptor_;
  metadata.reflection = GCHappyRoll_reflection_;
  return metadata;
}


// ===================================================================

#ifndef _MSC_VER
const int GCHappyRollRewardList::kHrRewardListFieldNumber;
const int GCHappyRollRewardList::kHrMulListFieldNumber;
const int GCHappyRollRewardList::kHrMulDesListFieldNumber;
#endif  // !_MSC_VER

GCHappyRollRewardList::GCHappyRollRewardList()
  : ::google::protobuf::Message() {
  SharedCtor();
  // @@protoc_insertion_point(constructor:GCHappyRollRewardList)
}

void GCHappyRollRewardList::InitAsDefaultInstance() {
}

GCHappyRollRewardList::GCHappyRollRewardList(const GCHappyRollRewardList& from)
  : ::google::protobuf::Message() {
  SharedCtor();
  MergeFrom(from);
  // @@protoc_insertion_point(copy_constructor:GCHappyRollRewardList)
}

void GCHappyRollRewardList::SharedCtor() {
  _cached_size_ = 0;
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

GCHappyRollRewardList::~GCHappyRollRewardList() {
  // @@protoc_insertion_point(destructor:GCHappyRollRewardList)
  SharedDtor();
}

void GCHappyRollRewardList::SharedDtor() {
  if (this != default_instance_) {
  }
}

void GCHappyRollRewardList::SetCachedSize(int size) const {
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
}
const ::google::protobuf::Descriptor* GCHappyRollRewardList::descriptor() {
  protobuf_AssignDescriptorsOnce();
  return GCHappyRollRewardList_descriptor_;
}

const GCHappyRollRewardList& GCHappyRollRewardList::default_instance() {
  if (default_instance_ == NULL) protobuf_AddDesc_HappyRollMessage_2eproto();
  return *default_instance_;
}

GCHappyRollRewardList* GCHappyRollRewardList::default_instance_ = NULL;

GCHappyRollRewardList* GCHappyRollRewardList::New() const {
  return new GCHappyRollRewardList;
}

void GCHappyRollRewardList::Clear() {
  hrrewardlist_.Clear();
  hrmullist_.Clear();
  hrmuldeslist_.Clear();
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
  mutable_unknown_fields()->Clear();
}

bool GCHappyRollRewardList::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!(EXPRESSION)) goto failure
  ::google::protobuf::uint32 tag;
  // @@protoc_insertion_point(parse_start:GCHappyRollRewardList)
  for (;;) {
    ::std::pair< ::google::protobuf::uint32, bool> p = input->ReadTagWithCutoff(127);
    tag = p.first;
    if (!p.second) goto handle_unusual;
    switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // repeated .HRRewardInfo hrRewardList = 1;
      case 1: {
        if (tag == 10) {
         parse_hrRewardList:
          DO_(::google::protobuf::internal::WireFormatLite::ReadMessageNoVirtual(
                input, add_hrrewardlist()));
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(10)) goto parse_hrRewardList;
        if (input->ExpectTag(16)) goto parse_hrMulList;
        break;
      }

      // repeated int32 hrMulList = 2;
      case 2: {
        if (tag == 16) {
         parse_hrMulList:
          DO_((::google::protobuf::internal::WireFormatLite::ReadRepeatedPrimitive<
                   ::google::protobuf::int32, ::google::protobuf::internal::WireFormatLite::TYPE_INT32>(
                 1, 16, input, this->mutable_hrmullist())));
        } else if (tag == 18) {
          DO_((::google::protobuf::internal::WireFormatLite::ReadPackedPrimitiveNoInline<
                   ::google::protobuf::int32, ::google::protobuf::internal::WireFormatLite::TYPE_INT32>(
                 input, this->mutable_hrmullist())));
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(16)) goto parse_hrMulList;
        if (input->ExpectTag(24)) goto parse_hrMulDesList;
        break;
      }

      // repeated int32 hrMulDesList = 3;
      case 3: {
        if (tag == 24) {
         parse_hrMulDesList:
          DO_((::google::protobuf::internal::WireFormatLite::ReadRepeatedPrimitive<
                   ::google::protobuf::int32, ::google::protobuf::internal::WireFormatLite::TYPE_INT32>(
                 1, 24, input, this->mutable_hrmuldeslist())));
        } else if (tag == 26) {
          DO_((::google::protobuf::internal::WireFormatLite::ReadPackedPrimitiveNoInline<
                   ::google::protobuf::int32, ::google::protobuf::internal::WireFormatLite::TYPE_INT32>(
                 input, this->mutable_hrmuldeslist())));
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(24)) goto parse_hrMulDesList;
        if (input->ExpectAtEnd()) goto success;
        break;
      }

      default: {
      handle_unusual:
        if (tag == 0 ||
            ::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_END_GROUP) {
          goto success;
        }
        DO_(::google::protobuf::internal::WireFormat::SkipField(
              input, tag, mutable_unknown_fields()));
        break;
      }
    }
  }
success:
  // @@protoc_insertion_point(parse_success:GCHappyRollRewardList)
  return true;
failure:
  // @@protoc_insertion_point(parse_failure:GCHappyRollRewardList)
  return false;
#undef DO_
}

void GCHappyRollRewardList::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // @@protoc_insertion_point(serialize_start:GCHappyRollRewardList)
  // repeated .HRRewardInfo hrRewardList = 1;
  for (int i = 0; i < this->hrrewardlist_size(); i++) {
    ::google::protobuf::internal::WireFormatLite::WriteMessageMaybeToArray(
      1, this->hrrewardlist(i), output);
  }

  // repeated int32 hrMulList = 2;
  for (int i = 0; i < this->hrmullist_size(); i++) {
    ::google::protobuf::internal::WireFormatLite::WriteInt32(
      2, this->hrmullist(i), output);
  }

  // repeated int32 hrMulDesList = 3;
  for (int i = 0; i < this->hrmuldeslist_size(); i++) {
    ::google::protobuf::internal::WireFormatLite::WriteInt32(
      3, this->hrmuldeslist(i), output);
  }

  if (!unknown_fields().empty()) {
    ::google::protobuf::internal::WireFormat::SerializeUnknownFields(
        unknown_fields(), output);
  }
  // @@protoc_insertion_point(serialize_end:GCHappyRollRewardList)
}

::google::protobuf::uint8* GCHappyRollRewardList::SerializeWithCachedSizesToArray(
    ::google::protobuf::uint8* target) const {
  // @@protoc_insertion_point(serialize_to_array_start:GCHappyRollRewardList)
  // repeated .HRRewardInfo hrRewardList = 1;
  for (int i = 0; i < this->hrrewardlist_size(); i++) {
    target = ::google::protobuf::internal::WireFormatLite::
      WriteMessageNoVirtualToArray(
        1, this->hrrewardlist(i), target);
  }

  // repeated int32 hrMulList = 2;
  for (int i = 0; i < this->hrmullist_size(); i++) {
    target = ::google::protobuf::internal::WireFormatLite::
      WriteInt32ToArray(2, this->hrmullist(i), target);
  }

  // repeated int32 hrMulDesList = 3;
  for (int i = 0; i < this->hrmuldeslist_size(); i++) {
    target = ::google::protobuf::internal::WireFormatLite::
      WriteInt32ToArray(3, this->hrmuldeslist(i), target);
  }

  if (!unknown_fields().empty()) {
    target = ::google::protobuf::internal::WireFormat::SerializeUnknownFieldsToArray(
        unknown_fields(), target);
  }
  // @@protoc_insertion_point(serialize_to_array_end:GCHappyRollRewardList)
  return target;
}

int GCHappyRollRewardList::ByteSize() const {
  int total_size = 0;

  // repeated .HRRewardInfo hrRewardList = 1;
  total_size += 1 * this->hrrewardlist_size();
  for (int i = 0; i < this->hrrewardlist_size(); i++) {
    total_size +=
      ::google::protobuf::internal::WireFormatLite::MessageSizeNoVirtual(
        this->hrrewardlist(i));
  }

  // repeated int32 hrMulList = 2;
  {
    int data_size = 0;
    for (int i = 0; i < this->hrmullist_size(); i++) {
      data_size += ::google::protobuf::internal::WireFormatLite::
        Int32Size(this->hrmullist(i));
    }
    total_size += 1 * this->hrmullist_size() + data_size;
  }

  // repeated int32 hrMulDesList = 3;
  {
    int data_size = 0;
    for (int i = 0; i < this->hrmuldeslist_size(); i++) {
      data_size += ::google::protobuf::internal::WireFormatLite::
        Int32Size(this->hrmuldeslist(i));
    }
    total_size += 1 * this->hrmuldeslist_size() + data_size;
  }

  if (!unknown_fields().empty()) {
    total_size +=
      ::google::protobuf::internal::WireFormat::ComputeUnknownFieldsSize(
        unknown_fields());
  }
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = total_size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
  return total_size;
}

void GCHappyRollRewardList::MergeFrom(const ::google::protobuf::Message& from) {
  GOOGLE_CHECK_NE(&from, this);
  const GCHappyRollRewardList* source =
    ::google::protobuf::internal::dynamic_cast_if_available<const GCHappyRollRewardList*>(
      &from);
  if (source == NULL) {
    ::google::protobuf::internal::ReflectionOps::Merge(from, this);
  } else {
    MergeFrom(*source);
  }
}

void GCHappyRollRewardList::MergeFrom(const GCHappyRollRewardList& from) {
  GOOGLE_CHECK_NE(&from, this);
  hrrewardlist_.MergeFrom(from.hrrewardlist_);
  hrmullist_.MergeFrom(from.hrmullist_);
  hrmuldeslist_.MergeFrom(from.hrmuldeslist_);
  mutable_unknown_fields()->MergeFrom(from.unknown_fields());
}

void GCHappyRollRewardList::CopyFrom(const ::google::protobuf::Message& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

void GCHappyRollRewardList::CopyFrom(const GCHappyRollRewardList& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool GCHappyRollRewardList::IsInitialized() const {

  return true;
}

void GCHappyRollRewardList::Swap(GCHappyRollRewardList* other) {
  if (other != this) {
    hrrewardlist_.Swap(&other->hrrewardlist_);
    hrmullist_.Swap(&other->hrmullist_);
    hrmuldeslist_.Swap(&other->hrmuldeslist_);
    std::swap(_has_bits_[0], other->_has_bits_[0]);
    _unknown_fields_.Swap(&other->_unknown_fields_);
    std::swap(_cached_size_, other->_cached_size_);
  }
}

::google::protobuf::Metadata GCHappyRollRewardList::GetMetadata() const {
  protobuf_AssignDescriptorsOnce();
  ::google::protobuf::Metadata metadata;
  metadata.descriptor = GCHappyRollRewardList_descriptor_;
  metadata.reflection = GCHappyRollRewardList_reflection_;
  return metadata;
}


// ===================================================================

#ifndef _MSC_VER
const int GCHappyRollJackPotList::kShowsFieldNumber;
#endif  // !_MSC_VER

GCHappyRollJackPotList::GCHappyRollJackPotList()
  : ::google::protobuf::Message() {
  SharedCtor();
  // @@protoc_insertion_point(constructor:GCHappyRollJackPotList)
}

void GCHappyRollJackPotList::InitAsDefaultInstance() {
}

GCHappyRollJackPotList::GCHappyRollJackPotList(const GCHappyRollJackPotList& from)
  : ::google::protobuf::Message() {
  SharedCtor();
  MergeFrom(from);
  // @@protoc_insertion_point(copy_constructor:GCHappyRollJackPotList)
}

void GCHappyRollJackPotList::SharedCtor() {
  _cached_size_ = 0;
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

GCHappyRollJackPotList::~GCHappyRollJackPotList() {
  // @@protoc_insertion_point(destructor:GCHappyRollJackPotList)
  SharedDtor();
}

void GCHappyRollJackPotList::SharedDtor() {
  if (this != default_instance_) {
  }
}

void GCHappyRollJackPotList::SetCachedSize(int size) const {
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
}
const ::google::protobuf::Descriptor* GCHappyRollJackPotList::descriptor() {
  protobuf_AssignDescriptorsOnce();
  return GCHappyRollJackPotList_descriptor_;
}

const GCHappyRollJackPotList& GCHappyRollJackPotList::default_instance() {
  if (default_instance_ == NULL) protobuf_AddDesc_HappyRollMessage_2eproto();
  return *default_instance_;
}

GCHappyRollJackPotList* GCHappyRollJackPotList::default_instance_ = NULL;

GCHappyRollJackPotList* GCHappyRollJackPotList::New() const {
  return new GCHappyRollJackPotList;
}

void GCHappyRollJackPotList::Clear() {
  shows_.Clear();
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
  mutable_unknown_fields()->Clear();
}

bool GCHappyRollJackPotList::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!(EXPRESSION)) goto failure
  ::google::protobuf::uint32 tag;
  // @@protoc_insertion_point(parse_start:GCHappyRollJackPotList)
  for (;;) {
    ::std::pair< ::google::protobuf::uint32, bool> p = input->ReadTagWithCutoff(127);
    tag = p.first;
    if (!p.second) goto handle_unusual;
    switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // repeated .ShowInfo shows = 1;
      case 1: {
        if (tag == 10) {
         parse_shows:
          DO_(::google::protobuf::internal::WireFormatLite::ReadMessageNoVirtual(
                input, add_shows()));
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(10)) goto parse_shows;
        if (input->ExpectAtEnd()) goto success;
        break;
      }

      default: {
      handle_unusual:
        if (tag == 0 ||
            ::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_END_GROUP) {
          goto success;
        }
        DO_(::google::protobuf::internal::WireFormat::SkipField(
              input, tag, mutable_unknown_fields()));
        break;
      }
    }
  }
success:
  // @@protoc_insertion_point(parse_success:GCHappyRollJackPotList)
  return true;
failure:
  // @@protoc_insertion_point(parse_failure:GCHappyRollJackPotList)
  return false;
#undef DO_
}

void GCHappyRollJackPotList::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // @@protoc_insertion_point(serialize_start:GCHappyRollJackPotList)
  // repeated .ShowInfo shows = 1;
  for (int i = 0; i < this->shows_size(); i++) {
    ::google::protobuf::internal::WireFormatLite::WriteMessageMaybeToArray(
      1, this->shows(i), output);
  }

  if (!unknown_fields().empty()) {
    ::google::protobuf::internal::WireFormat::SerializeUnknownFields(
        unknown_fields(), output);
  }
  // @@protoc_insertion_point(serialize_end:GCHappyRollJackPotList)
}

::google::protobuf::uint8* GCHappyRollJackPotList::SerializeWithCachedSizesToArray(
    ::google::protobuf::uint8* target) const {
  // @@protoc_insertion_point(serialize_to_array_start:GCHappyRollJackPotList)
  // repeated .ShowInfo shows = 1;
  for (int i = 0; i < this->shows_size(); i++) {
    target = ::google::protobuf::internal::WireFormatLite::
      WriteMessageNoVirtualToArray(
        1, this->shows(i), target);
  }

  if (!unknown_fields().empty()) {
    target = ::google::protobuf::internal::WireFormat::SerializeUnknownFieldsToArray(
        unknown_fields(), target);
  }
  // @@protoc_insertion_point(serialize_to_array_end:GCHappyRollJackPotList)
  return target;
}

int GCHappyRollJackPotList::ByteSize() const {
  int total_size = 0;

  // repeated .ShowInfo shows = 1;
  total_size += 1 * this->shows_size();
  for (int i = 0; i < this->shows_size(); i++) {
    total_size +=
      ::google::protobuf::internal::WireFormatLite::MessageSizeNoVirtual(
        this->shows(i));
  }

  if (!unknown_fields().empty()) {
    total_size +=
      ::google::protobuf::internal::WireFormat::ComputeUnknownFieldsSize(
        unknown_fields());
  }
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = total_size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
  return total_size;
}

void GCHappyRollJackPotList::MergeFrom(const ::google::protobuf::Message& from) {
  GOOGLE_CHECK_NE(&from, this);
  const GCHappyRollJackPotList* source =
    ::google::protobuf::internal::dynamic_cast_if_available<const GCHappyRollJackPotList*>(
      &from);
  if (source == NULL) {
    ::google::protobuf::internal::ReflectionOps::Merge(from, this);
  } else {
    MergeFrom(*source);
  }
}

void GCHappyRollJackPotList::MergeFrom(const GCHappyRollJackPotList& from) {
  GOOGLE_CHECK_NE(&from, this);
  shows_.MergeFrom(from.shows_);
  mutable_unknown_fields()->MergeFrom(from.unknown_fields());
}

void GCHappyRollJackPotList::CopyFrom(const ::google::protobuf::Message& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

void GCHappyRollJackPotList::CopyFrom(const GCHappyRollJackPotList& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool GCHappyRollJackPotList::IsInitialized() const {

  return true;
}

void GCHappyRollJackPotList::Swap(GCHappyRollJackPotList* other) {
  if (other != this) {
    shows_.Swap(&other->shows_);
    std::swap(_has_bits_[0], other->_has_bits_[0]);
    _unknown_fields_.Swap(&other->_unknown_fields_);
    std::swap(_cached_size_, other->_cached_size_);
  }
}

::google::protobuf::Metadata GCHappyRollJackPotList::GetMetadata() const {
  protobuf_AssignDescriptorsOnce();
  ::google::protobuf::Metadata metadata;
  metadata.descriptor = GCHappyRollJackPotList_descriptor_;
  metadata.reflection = GCHappyRollJackPotList_reflection_;
  return metadata;
}


// ===================================================================

#ifndef _MSC_VER
const int CGLottery::kChoseRewardIDListFieldNumber;
const int CGLottery::kChoseMultipleFieldNumber;
#endif  // !_MSC_VER

CGLottery::CGLottery()
  : ::google::protobuf::Message() {
  SharedCtor();
  // @@protoc_insertion_point(constructor:CGLottery)
}

void CGLottery::InitAsDefaultInstance() {
}

CGLottery::CGLottery(const CGLottery& from)
  : ::google::protobuf::Message() {
  SharedCtor();
  MergeFrom(from);
  // @@protoc_insertion_point(copy_constructor:CGLottery)
}

void CGLottery::SharedCtor() {
  _cached_size_ = 0;
  chosemultiple_ = 0;
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

CGLottery::~CGLottery() {
  // @@protoc_insertion_point(destructor:CGLottery)
  SharedDtor();
}

void CGLottery::SharedDtor() {
  if (this != default_instance_) {
  }
}

void CGLottery::SetCachedSize(int size) const {
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
}
const ::google::protobuf::Descriptor* CGLottery::descriptor() {
  protobuf_AssignDescriptorsOnce();
  return CGLottery_descriptor_;
}

const CGLottery& CGLottery::default_instance() {
  if (default_instance_ == NULL) protobuf_AddDesc_HappyRollMessage_2eproto();
  return *default_instance_;
}

CGLottery* CGLottery::default_instance_ = NULL;

CGLottery* CGLottery::New() const {
  return new CGLottery;
}

void CGLottery::Clear() {
  chosemultiple_ = 0;
  choserewardidlist_.Clear();
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
  mutable_unknown_fields()->Clear();
}

bool CGLottery::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!(EXPRESSION)) goto failure
  ::google::protobuf::uint32 tag;
  // @@protoc_insertion_point(parse_start:CGLottery)
  for (;;) {
    ::std::pair< ::google::protobuf::uint32, bool> p = input->ReadTagWithCutoff(127);
    tag = p.first;
    if (!p.second) goto handle_unusual;
    switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // repeated int32 choseRewardIDList = 1;
      case 1: {
        if (tag == 8) {
         parse_choseRewardIDList:
          DO_((::google::protobuf::internal::WireFormatLite::ReadRepeatedPrimitive<
                   ::google::protobuf::int32, ::google::protobuf::internal::WireFormatLite::TYPE_INT32>(
                 1, 8, input, this->mutable_choserewardidlist())));
        } else if (tag == 10) {
          DO_((::google::protobuf::internal::WireFormatLite::ReadPackedPrimitiveNoInline<
                   ::google::protobuf::int32, ::google::protobuf::internal::WireFormatLite::TYPE_INT32>(
                 input, this->mutable_choserewardidlist())));
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(8)) goto parse_choseRewardIDList;
        if (input->ExpectTag(16)) goto parse_choseMultiple;
        break;
      }

      // optional int32 choseMultiple = 2;
      case 2: {
        if (tag == 16) {
         parse_choseMultiple:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::int32, ::google::protobuf::internal::WireFormatLite::TYPE_INT32>(
                 input, &chosemultiple_)));
          set_has_chosemultiple();
        } else {
          goto handle_unusual;
        }
        if (input->ExpectAtEnd()) goto success;
        break;
      }

      default: {
      handle_unusual:
        if (tag == 0 ||
            ::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_END_GROUP) {
          goto success;
        }
        DO_(::google::protobuf::internal::WireFormat::SkipField(
              input, tag, mutable_unknown_fields()));
        break;
      }
    }
  }
success:
  // @@protoc_insertion_point(parse_success:CGLottery)
  return true;
failure:
  // @@protoc_insertion_point(parse_failure:CGLottery)
  return false;
#undef DO_
}

void CGLottery::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // @@protoc_insertion_point(serialize_start:CGLottery)
  // repeated int32 choseRewardIDList = 1;
  for (int i = 0; i < this->choserewardidlist_size(); i++) {
    ::google::protobuf::internal::WireFormatLite::WriteInt32(
      1, this->choserewardidlist(i), output);
  }

  // optional int32 choseMultiple = 2;
  if (has_chosemultiple()) {
    ::google::protobuf::internal::WireFormatLite::WriteInt32(2, this->chosemultiple(), output);
  }

  if (!unknown_fields().empty()) {
    ::google::protobuf::internal::WireFormat::SerializeUnknownFields(
        unknown_fields(), output);
  }
  // @@protoc_insertion_point(serialize_end:CGLottery)
}

::google::protobuf::uint8* CGLottery::SerializeWithCachedSizesToArray(
    ::google::protobuf::uint8* target) const {
  // @@protoc_insertion_point(serialize_to_array_start:CGLottery)
  // repeated int32 choseRewardIDList = 1;
  for (int i = 0; i < this->choserewardidlist_size(); i++) {
    target = ::google::protobuf::internal::WireFormatLite::
      WriteInt32ToArray(1, this->choserewardidlist(i), target);
  }

  // optional int32 choseMultiple = 2;
  if (has_chosemultiple()) {
    target = ::google::protobuf::internal::WireFormatLite::WriteInt32ToArray(2, this->chosemultiple(), target);
  }

  if (!unknown_fields().empty()) {
    target = ::google::protobuf::internal::WireFormat::SerializeUnknownFieldsToArray(
        unknown_fields(), target);
  }
  // @@protoc_insertion_point(serialize_to_array_end:CGLottery)
  return target;
}

int CGLottery::ByteSize() const {
  int total_size = 0;

  if (_has_bits_[1 / 32] & (0xffu << (1 % 32))) {
    // optional int32 choseMultiple = 2;
    if (has_chosemultiple()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::Int32Size(
          this->chosemultiple());
    }

  }
  // repeated int32 choseRewardIDList = 1;
  {
    int data_size = 0;
    for (int i = 0; i < this->choserewardidlist_size(); i++) {
      data_size += ::google::protobuf::internal::WireFormatLite::
        Int32Size(this->choserewardidlist(i));
    }
    total_size += 1 * this->choserewardidlist_size() + data_size;
  }

  if (!unknown_fields().empty()) {
    total_size +=
      ::google::protobuf::internal::WireFormat::ComputeUnknownFieldsSize(
        unknown_fields());
  }
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = total_size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
  return total_size;
}

void CGLottery::MergeFrom(const ::google::protobuf::Message& from) {
  GOOGLE_CHECK_NE(&from, this);
  const CGLottery* source =
    ::google::protobuf::internal::dynamic_cast_if_available<const CGLottery*>(
      &from);
  if (source == NULL) {
    ::google::protobuf::internal::ReflectionOps::Merge(from, this);
  } else {
    MergeFrom(*source);
  }
}

void CGLottery::MergeFrom(const CGLottery& from) {
  GOOGLE_CHECK_NE(&from, this);
  choserewardidlist_.MergeFrom(from.choserewardidlist_);
  if (from._has_bits_[1 / 32] & (0xffu << (1 % 32))) {
    if (from.has_chosemultiple()) {
      set_chosemultiple(from.chosemultiple());
    }
  }
  mutable_unknown_fields()->MergeFrom(from.unknown_fields());
}

void CGLottery::CopyFrom(const ::google::protobuf::Message& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

void CGLottery::CopyFrom(const CGLottery& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool CGLottery::IsInitialized() const {

  return true;
}

void CGLottery::Swap(CGLottery* other) {
  if (other != this) {
    choserewardidlist_.Swap(&other->choserewardidlist_);
    std::swap(chosemultiple_, other->chosemultiple_);
    std::swap(_has_bits_[0], other->_has_bits_[0]);
    _unknown_fields_.Swap(&other->_unknown_fields_);
    std::swap(_cached_size_, other->_cached_size_);
  }
}

::google::protobuf::Metadata CGLottery::GetMetadata() const {
  protobuf_AssignDescriptorsOnce();
  ::google::protobuf::Metadata metadata;
  metadata.descriptor = CGLottery_descriptor_;
  metadata.reflection = CGLottery_reflection_;
  return metadata;
}


// ===================================================================

#ifndef _MSC_VER
const int GCLottery::kResultFieldNumber;
const int GCLottery::kTargetIDFieldNumber;
const int GCLottery::kIntegralFieldNumber;
#endif  // !_MSC_VER

GCLottery::GCLottery()
  : ::google::protobuf::Message() {
  SharedCtor();
  // @@protoc_insertion_point(constructor:GCLottery)
}

void GCLottery::InitAsDefaultInstance() {
}

GCLottery::GCLottery(const GCLottery& from)
  : ::google::protobuf::Message() {
  SharedCtor();
  MergeFrom(from);
  // @@protoc_insertion_point(copy_constructor:GCLottery)
}

void GCLottery::SharedCtor() {
  _cached_size_ = 0;
  result_ = 0;
  targetid_ = 0;
  integral_ = 0;
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

GCLottery::~GCLottery() {
  // @@protoc_insertion_point(destructor:GCLottery)
  SharedDtor();
}

void GCLottery::SharedDtor() {
  if (this != default_instance_) {
  }
}

void GCLottery::SetCachedSize(int size) const {
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
}
const ::google::protobuf::Descriptor* GCLottery::descriptor() {
  protobuf_AssignDescriptorsOnce();
  return GCLottery_descriptor_;
}

const GCLottery& GCLottery::default_instance() {
  if (default_instance_ == NULL) protobuf_AddDesc_HappyRollMessage_2eproto();
  return *default_instance_;
}

GCLottery* GCLottery::default_instance_ = NULL;

GCLottery* GCLottery::New() const {
  return new GCLottery;
}

void GCLottery::Clear() {
#define OFFSET_OF_FIELD_(f) (reinterpret_cast<char*>(      \
  &reinterpret_cast<GCLottery*>(16)->f) - \
   reinterpret_cast<char*>(16))

#define ZR_(first, last) do {                              \
    size_t f = OFFSET_OF_FIELD_(first);                    \
    size_t n = OFFSET_OF_FIELD_(last) - f + sizeof(last);  \
    ::memset(&first, 0, n);                                \
  } while (0)

  ZR_(result_, integral_);

#undef OFFSET_OF_FIELD_
#undef ZR_

  ::memset(_has_bits_, 0, sizeof(_has_bits_));
  mutable_unknown_fields()->Clear();
}

bool GCLottery::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!(EXPRESSION)) goto failure
  ::google::protobuf::uint32 tag;
  // @@protoc_insertion_point(parse_start:GCLottery)
  for (;;) {
    ::std::pair< ::google::protobuf::uint32, bool> p = input->ReadTagWithCutoff(127);
    tag = p.first;
    if (!p.second) goto handle_unusual;
    switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // optional int32 result = 1;
      case 1: {
        if (tag == 8) {
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::int32, ::google::protobuf::internal::WireFormatLite::TYPE_INT32>(
                 input, &result_)));
          set_has_result();
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(16)) goto parse_targetID;
        break;
      }

      // optional int32 targetID = 2;
      case 2: {
        if (tag == 16) {
         parse_targetID:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::int32, ::google::protobuf::internal::WireFormatLite::TYPE_INT32>(
                 input, &targetid_)));
          set_has_targetid();
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(24)) goto parse_integral;
        break;
      }

      // optional int32 integral = 3;
      case 3: {
        if (tag == 24) {
         parse_integral:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::int32, ::google::protobuf::internal::WireFormatLite::TYPE_INT32>(
                 input, &integral_)));
          set_has_integral();
        } else {
          goto handle_unusual;
        }
        if (input->ExpectAtEnd()) goto success;
        break;
      }

      default: {
      handle_unusual:
        if (tag == 0 ||
            ::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_END_GROUP) {
          goto success;
        }
        DO_(::google::protobuf::internal::WireFormat::SkipField(
              input, tag, mutable_unknown_fields()));
        break;
      }
    }
  }
success:
  // @@protoc_insertion_point(parse_success:GCLottery)
  return true;
failure:
  // @@protoc_insertion_point(parse_failure:GCLottery)
  return false;
#undef DO_
}

void GCLottery::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // @@protoc_insertion_point(serialize_start:GCLottery)
  // optional int32 result = 1;
  if (has_result()) {
    ::google::protobuf::internal::WireFormatLite::WriteInt32(1, this->result(), output);
  }

  // optional int32 targetID = 2;
  if (has_targetid()) {
    ::google::protobuf::internal::WireFormatLite::WriteInt32(2, this->targetid(), output);
  }

  // optional int32 integral = 3;
  if (has_integral()) {
    ::google::protobuf::internal::WireFormatLite::WriteInt32(3, this->integral(), output);
  }

  if (!unknown_fields().empty()) {
    ::google::protobuf::internal::WireFormat::SerializeUnknownFields(
        unknown_fields(), output);
  }
  // @@protoc_insertion_point(serialize_end:GCLottery)
}

::google::protobuf::uint8* GCLottery::SerializeWithCachedSizesToArray(
    ::google::protobuf::uint8* target) const {
  // @@protoc_insertion_point(serialize_to_array_start:GCLottery)
  // optional int32 result = 1;
  if (has_result()) {
    target = ::google::protobuf::internal::WireFormatLite::WriteInt32ToArray(1, this->result(), target);
  }

  // optional int32 targetID = 2;
  if (has_targetid()) {
    target = ::google::protobuf::internal::WireFormatLite::WriteInt32ToArray(2, this->targetid(), target);
  }

  // optional int32 integral = 3;
  if (has_integral()) {
    target = ::google::protobuf::internal::WireFormatLite::WriteInt32ToArray(3, this->integral(), target);
  }

  if (!unknown_fields().empty()) {
    target = ::google::protobuf::internal::WireFormat::SerializeUnknownFieldsToArray(
        unknown_fields(), target);
  }
  // @@protoc_insertion_point(serialize_to_array_end:GCLottery)
  return target;
}

int GCLottery::ByteSize() const {
  int total_size = 0;

  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    // optional int32 result = 1;
    if (has_result()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::Int32Size(
          this->result());
    }

    // optional int32 targetID = 2;
    if (has_targetid()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::Int32Size(
          this->targetid());
    }

    // optional int32 integral = 3;
    if (has_integral()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::Int32Size(
          this->integral());
    }

  }
  if (!unknown_fields().empty()) {
    total_size +=
      ::google::protobuf::internal::WireFormat::ComputeUnknownFieldsSize(
        unknown_fields());
  }
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = total_size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
  return total_size;
}

void GCLottery::MergeFrom(const ::google::protobuf::Message& from) {
  GOOGLE_CHECK_NE(&from, this);
  const GCLottery* source =
    ::google::protobuf::internal::dynamic_cast_if_available<const GCLottery*>(
      &from);
  if (source == NULL) {
    ::google::protobuf::internal::ReflectionOps::Merge(from, this);
  } else {
    MergeFrom(*source);
  }
}

void GCLottery::MergeFrom(const GCLottery& from) {
  GOOGLE_CHECK_NE(&from, this);
  if (from._has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    if (from.has_result()) {
      set_result(from.result());
    }
    if (from.has_targetid()) {
      set_targetid(from.targetid());
    }
    if (from.has_integral()) {
      set_integral(from.integral());
    }
  }
  mutable_unknown_fields()->MergeFrom(from.unknown_fields());
}

void GCLottery::CopyFrom(const ::google::protobuf::Message& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

void GCLottery::CopyFrom(const GCLottery& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool GCLottery::IsInitialized() const {

  return true;
}

void GCLottery::Swap(GCLottery* other) {
  if (other != this) {
    std::swap(result_, other->result_);
    std::swap(targetid_, other->targetid_);
    std::swap(integral_, other->integral_);
    std::swap(_has_bits_[0], other->_has_bits_[0]);
    _unknown_fields_.Swap(&other->_unknown_fields_);
    std::swap(_cached_size_, other->_cached_size_);
  }
}

::google::protobuf::Metadata GCLottery::GetMetadata() const {
  protobuf_AssignDescriptorsOnce();
  ::google::protobuf::Metadata metadata;
  metadata.descriptor = GCLottery_descriptor_;
  metadata.reflection = GCLottery_reflection_;
  return metadata;
}


// ===================================================================

#ifndef _MSC_VER
#endif  // !_MSC_VER

CGHappyRollGetReward::CGHappyRollGetReward()
  : ::google::protobuf::Message() {
  SharedCtor();
  // @@protoc_insertion_point(constructor:CGHappyRollGetReward)
}

void CGHappyRollGetReward::InitAsDefaultInstance() {
}

CGHappyRollGetReward::CGHappyRollGetReward(const CGHappyRollGetReward& from)
  : ::google::protobuf::Message() {
  SharedCtor();
  MergeFrom(from);
  // @@protoc_insertion_point(copy_constructor:CGHappyRollGetReward)
}

void CGHappyRollGetReward::SharedCtor() {
  _cached_size_ = 0;
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

CGHappyRollGetReward::~CGHappyRollGetReward() {
  // @@protoc_insertion_point(destructor:CGHappyRollGetReward)
  SharedDtor();
}

void CGHappyRollGetReward::SharedDtor() {
  if (this != default_instance_) {
  }
}

void CGHappyRollGetReward::SetCachedSize(int size) const {
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
}
const ::google::protobuf::Descriptor* CGHappyRollGetReward::descriptor() {
  protobuf_AssignDescriptorsOnce();
  return CGHappyRollGetReward_descriptor_;
}

const CGHappyRollGetReward& CGHappyRollGetReward::default_instance() {
  if (default_instance_ == NULL) protobuf_AddDesc_HappyRollMessage_2eproto();
  return *default_instance_;
}

CGHappyRollGetReward* CGHappyRollGetReward::default_instance_ = NULL;

CGHappyRollGetReward* CGHappyRollGetReward::New() const {
  return new CGHappyRollGetReward;
}

void CGHappyRollGetReward::Clear() {
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
  mutable_unknown_fields()->Clear();
}

bool CGHappyRollGetReward::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!(EXPRESSION)) goto failure
  ::google::protobuf::uint32 tag;
  // @@protoc_insertion_point(parse_start:CGHappyRollGetReward)
  for (;;) {
    ::std::pair< ::google::protobuf::uint32, bool> p = input->ReadTagWithCutoff(127);
    tag = p.first;
    if (!p.second) goto handle_unusual;
  handle_unusual:
    if (tag == 0 ||
        ::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
        ::google::protobuf::internal::WireFormatLite::WIRETYPE_END_GROUP) {
      goto success;
    }
    DO_(::google::protobuf::internal::WireFormat::SkipField(
          input, tag, mutable_unknown_fields()));
  }
success:
  // @@protoc_insertion_point(parse_success:CGHappyRollGetReward)
  return true;
failure:
  // @@protoc_insertion_point(parse_failure:CGHappyRollGetReward)
  return false;
#undef DO_
}

void CGHappyRollGetReward::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // @@protoc_insertion_point(serialize_start:CGHappyRollGetReward)
  if (!unknown_fields().empty()) {
    ::google::protobuf::internal::WireFormat::SerializeUnknownFields(
        unknown_fields(), output);
  }
  // @@protoc_insertion_point(serialize_end:CGHappyRollGetReward)
}

::google::protobuf::uint8* CGHappyRollGetReward::SerializeWithCachedSizesToArray(
    ::google::protobuf::uint8* target) const {
  // @@protoc_insertion_point(serialize_to_array_start:CGHappyRollGetReward)
  if (!unknown_fields().empty()) {
    target = ::google::protobuf::internal::WireFormat::SerializeUnknownFieldsToArray(
        unknown_fields(), target);
  }
  // @@protoc_insertion_point(serialize_to_array_end:CGHappyRollGetReward)
  return target;
}

int CGHappyRollGetReward::ByteSize() const {
  int total_size = 0;

  if (!unknown_fields().empty()) {
    total_size +=
      ::google::protobuf::internal::WireFormat::ComputeUnknownFieldsSize(
        unknown_fields());
  }
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = total_size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
  return total_size;
}

void CGHappyRollGetReward::MergeFrom(const ::google::protobuf::Message& from) {
  GOOGLE_CHECK_NE(&from, this);
  const CGHappyRollGetReward* source =
    ::google::protobuf::internal::dynamic_cast_if_available<const CGHappyRollGetReward*>(
      &from);
  if (source == NULL) {
    ::google::protobuf::internal::ReflectionOps::Merge(from, this);
  } else {
    MergeFrom(*source);
  }
}

void CGHappyRollGetReward::MergeFrom(const CGHappyRollGetReward& from) {
  GOOGLE_CHECK_NE(&from, this);
  mutable_unknown_fields()->MergeFrom(from.unknown_fields());
}

void CGHappyRollGetReward::CopyFrom(const ::google::protobuf::Message& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

void CGHappyRollGetReward::CopyFrom(const CGHappyRollGetReward& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool CGHappyRollGetReward::IsInitialized() const {

  return true;
}

void CGHappyRollGetReward::Swap(CGHappyRollGetReward* other) {
  if (other != this) {
    _unknown_fields_.Swap(&other->_unknown_fields_);
    std::swap(_cached_size_, other->_cached_size_);
  }
}

::google::protobuf::Metadata CGHappyRollGetReward::GetMetadata() const {
  protobuf_AssignDescriptorsOnce();
  ::google::protobuf::Metadata metadata;
  metadata.descriptor = CGHappyRollGetReward_descriptor_;
  metadata.reflection = CGHappyRollGetReward_reflection_;
  return metadata;
}


// ===================================================================

#ifndef _MSC_VER
const int GCHappyRollGetRewardBack::kResultFieldNumber;
#endif  // !_MSC_VER

GCHappyRollGetRewardBack::GCHappyRollGetRewardBack()
  : ::google::protobuf::Message() {
  SharedCtor();
  // @@protoc_insertion_point(constructor:GCHappyRollGetRewardBack)
}

void GCHappyRollGetRewardBack::InitAsDefaultInstance() {
}

GCHappyRollGetRewardBack::GCHappyRollGetRewardBack(const GCHappyRollGetRewardBack& from)
  : ::google::protobuf::Message() {
  SharedCtor();
  MergeFrom(from);
  // @@protoc_insertion_point(copy_constructor:GCHappyRollGetRewardBack)
}

void GCHappyRollGetRewardBack::SharedCtor() {
  _cached_size_ = 0;
  result_ = 0;
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

GCHappyRollGetRewardBack::~GCHappyRollGetRewardBack() {
  // @@protoc_insertion_point(destructor:GCHappyRollGetRewardBack)
  SharedDtor();
}

void GCHappyRollGetRewardBack::SharedDtor() {
  if (this != default_instance_) {
  }
}

void GCHappyRollGetRewardBack::SetCachedSize(int size) const {
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
}
const ::google::protobuf::Descriptor* GCHappyRollGetRewardBack::descriptor() {
  protobuf_AssignDescriptorsOnce();
  return GCHappyRollGetRewardBack_descriptor_;
}

const GCHappyRollGetRewardBack& GCHappyRollGetRewardBack::default_instance() {
  if (default_instance_ == NULL) protobuf_AddDesc_HappyRollMessage_2eproto();
  return *default_instance_;
}

GCHappyRollGetRewardBack* GCHappyRollGetRewardBack::default_instance_ = NULL;

GCHappyRollGetRewardBack* GCHappyRollGetRewardBack::New() const {
  return new GCHappyRollGetRewardBack;
}

void GCHappyRollGetRewardBack::Clear() {
  result_ = 0;
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
  mutable_unknown_fields()->Clear();
}

bool GCHappyRollGetRewardBack::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!(EXPRESSION)) goto failure
  ::google::protobuf::uint32 tag;
  // @@protoc_insertion_point(parse_start:GCHappyRollGetRewardBack)
  for (;;) {
    ::std::pair< ::google::protobuf::uint32, bool> p = input->ReadTagWithCutoff(127);
    tag = p.first;
    if (!p.second) goto handle_unusual;
    switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // optional int32 result = 1;
      case 1: {
        if (tag == 8) {
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::int32, ::google::protobuf::internal::WireFormatLite::TYPE_INT32>(
                 input, &result_)));
          set_has_result();
        } else {
          goto handle_unusual;
        }
        if (input->ExpectAtEnd()) goto success;
        break;
      }

      default: {
      handle_unusual:
        if (tag == 0 ||
            ::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_END_GROUP) {
          goto success;
        }
        DO_(::google::protobuf::internal::WireFormat::SkipField(
              input, tag, mutable_unknown_fields()));
        break;
      }
    }
  }
success:
  // @@protoc_insertion_point(parse_success:GCHappyRollGetRewardBack)
  return true;
failure:
  // @@protoc_insertion_point(parse_failure:GCHappyRollGetRewardBack)
  return false;
#undef DO_
}

void GCHappyRollGetRewardBack::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // @@protoc_insertion_point(serialize_start:GCHappyRollGetRewardBack)
  // optional int32 result = 1;
  if (has_result()) {
    ::google::protobuf::internal::WireFormatLite::WriteInt32(1, this->result(), output);
  }

  if (!unknown_fields().empty()) {
    ::google::protobuf::internal::WireFormat::SerializeUnknownFields(
        unknown_fields(), output);
  }
  // @@protoc_insertion_point(serialize_end:GCHappyRollGetRewardBack)
}

::google::protobuf::uint8* GCHappyRollGetRewardBack::SerializeWithCachedSizesToArray(
    ::google::protobuf::uint8* target) const {
  // @@protoc_insertion_point(serialize_to_array_start:GCHappyRollGetRewardBack)
  // optional int32 result = 1;
  if (has_result()) {
    target = ::google::protobuf::internal::WireFormatLite::WriteInt32ToArray(1, this->result(), target);
  }

  if (!unknown_fields().empty()) {
    target = ::google::protobuf::internal::WireFormat::SerializeUnknownFieldsToArray(
        unknown_fields(), target);
  }
  // @@protoc_insertion_point(serialize_to_array_end:GCHappyRollGetRewardBack)
  return target;
}

int GCHappyRollGetRewardBack::ByteSize() const {
  int total_size = 0;

  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    // optional int32 result = 1;
    if (has_result()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::Int32Size(
          this->result());
    }

  }
  if (!unknown_fields().empty()) {
    total_size +=
      ::google::protobuf::internal::WireFormat::ComputeUnknownFieldsSize(
        unknown_fields());
  }
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = total_size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
  return total_size;
}

void GCHappyRollGetRewardBack::MergeFrom(const ::google::protobuf::Message& from) {
  GOOGLE_CHECK_NE(&from, this);
  const GCHappyRollGetRewardBack* source =
    ::google::protobuf::internal::dynamic_cast_if_available<const GCHappyRollGetRewardBack*>(
      &from);
  if (source == NULL) {
    ::google::protobuf::internal::ReflectionOps::Merge(from, this);
  } else {
    MergeFrom(*source);
  }
}

void GCHappyRollGetRewardBack::MergeFrom(const GCHappyRollGetRewardBack& from) {
  GOOGLE_CHECK_NE(&from, this);
  if (from._has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    if (from.has_result()) {
      set_result(from.result());
    }
  }
  mutable_unknown_fields()->MergeFrom(from.unknown_fields());
}

void GCHappyRollGetRewardBack::CopyFrom(const ::google::protobuf::Message& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

void GCHappyRollGetRewardBack::CopyFrom(const GCHappyRollGetRewardBack& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool GCHappyRollGetRewardBack::IsInitialized() const {

  return true;
}

void GCHappyRollGetRewardBack::Swap(GCHappyRollGetRewardBack* other) {
  if (other != this) {
    std::swap(result_, other->result_);
    std::swap(_has_bits_[0], other->_has_bits_[0]);
    _unknown_fields_.Swap(&other->_unknown_fields_);
    std::swap(_cached_size_, other->_cached_size_);
  }
}

::google::protobuf::Metadata GCHappyRollGetRewardBack::GetMetadata() const {
  protobuf_AssignDescriptorsOnce();
  ::google::protobuf::Metadata metadata;
  metadata.descriptor = GCHappyRollGetRewardBack_descriptor_;
  metadata.reflection = GCHappyRollGetRewardBack_reflection_;
  return metadata;
}


// ===================================================================

#ifndef _MSC_VER
#endif  // !_MSC_VER

CGCheckHRUpdate::CGCheckHRUpdate()
  : ::google::protobuf::Message() {
  SharedCtor();
  // @@protoc_insertion_point(constructor:CGCheckHRUpdate)
}

void CGCheckHRUpdate::InitAsDefaultInstance() {
}

CGCheckHRUpdate::CGCheckHRUpdate(const CGCheckHRUpdate& from)
  : ::google::protobuf::Message() {
  SharedCtor();
  MergeFrom(from);
  // @@protoc_insertion_point(copy_constructor:CGCheckHRUpdate)
}

void CGCheckHRUpdate::SharedCtor() {
  _cached_size_ = 0;
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

CGCheckHRUpdate::~CGCheckHRUpdate() {
  // @@protoc_insertion_point(destructor:CGCheckHRUpdate)
  SharedDtor();
}

void CGCheckHRUpdate::SharedDtor() {
  if (this != default_instance_) {
  }
}

void CGCheckHRUpdate::SetCachedSize(int size) const {
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
}
const ::google::protobuf::Descriptor* CGCheckHRUpdate::descriptor() {
  protobuf_AssignDescriptorsOnce();
  return CGCheckHRUpdate_descriptor_;
}

const CGCheckHRUpdate& CGCheckHRUpdate::default_instance() {
  if (default_instance_ == NULL) protobuf_AddDesc_HappyRollMessage_2eproto();
  return *default_instance_;
}

CGCheckHRUpdate* CGCheckHRUpdate::default_instance_ = NULL;

CGCheckHRUpdate* CGCheckHRUpdate::New() const {
  return new CGCheckHRUpdate;
}

void CGCheckHRUpdate::Clear() {
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
  mutable_unknown_fields()->Clear();
}

bool CGCheckHRUpdate::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!(EXPRESSION)) goto failure
  ::google::protobuf::uint32 tag;
  // @@protoc_insertion_point(parse_start:CGCheckHRUpdate)
  for (;;) {
    ::std::pair< ::google::protobuf::uint32, bool> p = input->ReadTagWithCutoff(127);
    tag = p.first;
    if (!p.second) goto handle_unusual;
  handle_unusual:
    if (tag == 0 ||
        ::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
        ::google::protobuf::internal::WireFormatLite::WIRETYPE_END_GROUP) {
      goto success;
    }
    DO_(::google::protobuf::internal::WireFormat::SkipField(
          input, tag, mutable_unknown_fields()));
  }
success:
  // @@protoc_insertion_point(parse_success:CGCheckHRUpdate)
  return true;
failure:
  // @@protoc_insertion_point(parse_failure:CGCheckHRUpdate)
  return false;
#undef DO_
}

void CGCheckHRUpdate::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // @@protoc_insertion_point(serialize_start:CGCheckHRUpdate)
  if (!unknown_fields().empty()) {
    ::google::protobuf::internal::WireFormat::SerializeUnknownFields(
        unknown_fields(), output);
  }
  // @@protoc_insertion_point(serialize_end:CGCheckHRUpdate)
}

::google::protobuf::uint8* CGCheckHRUpdate::SerializeWithCachedSizesToArray(
    ::google::protobuf::uint8* target) const {
  // @@protoc_insertion_point(serialize_to_array_start:CGCheckHRUpdate)
  if (!unknown_fields().empty()) {
    target = ::google::protobuf::internal::WireFormat::SerializeUnknownFieldsToArray(
        unknown_fields(), target);
  }
  // @@protoc_insertion_point(serialize_to_array_end:CGCheckHRUpdate)
  return target;
}

int CGCheckHRUpdate::ByteSize() const {
  int total_size = 0;

  if (!unknown_fields().empty()) {
    total_size +=
      ::google::protobuf::internal::WireFormat::ComputeUnknownFieldsSize(
        unknown_fields());
  }
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = total_size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
  return total_size;
}

void CGCheckHRUpdate::MergeFrom(const ::google::protobuf::Message& from) {
  GOOGLE_CHECK_NE(&from, this);
  const CGCheckHRUpdate* source =
    ::google::protobuf::internal::dynamic_cast_if_available<const CGCheckHRUpdate*>(
      &from);
  if (source == NULL) {
    ::google::protobuf::internal::ReflectionOps::Merge(from, this);
  } else {
    MergeFrom(*source);
  }
}

void CGCheckHRUpdate::MergeFrom(const CGCheckHRUpdate& from) {
  GOOGLE_CHECK_NE(&from, this);
  mutable_unknown_fields()->MergeFrom(from.unknown_fields());
}

void CGCheckHRUpdate::CopyFrom(const ::google::protobuf::Message& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

void CGCheckHRUpdate::CopyFrom(const CGCheckHRUpdate& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool CGCheckHRUpdate::IsInitialized() const {

  return true;
}

void CGCheckHRUpdate::Swap(CGCheckHRUpdate* other) {
  if (other != this) {
    _unknown_fields_.Swap(&other->_unknown_fields_);
    std::swap(_cached_size_, other->_cached_size_);
  }
}

::google::protobuf::Metadata CGCheckHRUpdate::GetMetadata() const {
  protobuf_AssignDescriptorsOnce();
  ::google::protobuf::Metadata metadata;
  metadata.descriptor = CGCheckHRUpdate_descriptor_;
  metadata.reflection = CGCheckHRUpdate_reflection_;
  return metadata;
}


// ===================================================================

#ifndef _MSC_VER
const int GCVersion::kVersionFieldNumber;
#endif  // !_MSC_VER

GCVersion::GCVersion()
  : ::google::protobuf::Message() {
  SharedCtor();
  // @@protoc_insertion_point(constructor:GCVersion)
}

void GCVersion::InitAsDefaultInstance() {
}

GCVersion::GCVersion(const GCVersion& from)
  : ::google::protobuf::Message() {
  SharedCtor();
  MergeFrom(from);
  // @@protoc_insertion_point(copy_constructor:GCVersion)
}

void GCVersion::SharedCtor() {
  _cached_size_ = 0;
  version_ = 0;
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

GCVersion::~GCVersion() {
  // @@protoc_insertion_point(destructor:GCVersion)
  SharedDtor();
}

void GCVersion::SharedDtor() {
  if (this != default_instance_) {
  }
}

void GCVersion::SetCachedSize(int size) const {
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
}
const ::google::protobuf::Descriptor* GCVersion::descriptor() {
  protobuf_AssignDescriptorsOnce();
  return GCVersion_descriptor_;
}

const GCVersion& GCVersion::default_instance() {
  if (default_instance_ == NULL) protobuf_AddDesc_HappyRollMessage_2eproto();
  return *default_instance_;
}

GCVersion* GCVersion::default_instance_ = NULL;

GCVersion* GCVersion::New() const {
  return new GCVersion;
}

void GCVersion::Clear() {
  version_ = 0;
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
  mutable_unknown_fields()->Clear();
}

bool GCVersion::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!(EXPRESSION)) goto failure
  ::google::protobuf::uint32 tag;
  // @@protoc_insertion_point(parse_start:GCVersion)
  for (;;) {
    ::std::pair< ::google::protobuf::uint32, bool> p = input->ReadTagWithCutoff(127);
    tag = p.first;
    if (!p.second) goto handle_unusual;
    switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // optional int32 version = 1;
      case 1: {
        if (tag == 8) {
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::int32, ::google::protobuf::internal::WireFormatLite::TYPE_INT32>(
                 input, &version_)));
          set_has_version();
        } else {
          goto handle_unusual;
        }
        if (input->ExpectAtEnd()) goto success;
        break;
      }

      default: {
      handle_unusual:
        if (tag == 0 ||
            ::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_END_GROUP) {
          goto success;
        }
        DO_(::google::protobuf::internal::WireFormat::SkipField(
              input, tag, mutable_unknown_fields()));
        break;
      }
    }
  }
success:
  // @@protoc_insertion_point(parse_success:GCVersion)
  return true;
failure:
  // @@protoc_insertion_point(parse_failure:GCVersion)
  return false;
#undef DO_
}

void GCVersion::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // @@protoc_insertion_point(serialize_start:GCVersion)
  // optional int32 version = 1;
  if (has_version()) {
    ::google::protobuf::internal::WireFormatLite::WriteInt32(1, this->version(), output);
  }

  if (!unknown_fields().empty()) {
    ::google::protobuf::internal::WireFormat::SerializeUnknownFields(
        unknown_fields(), output);
  }
  // @@protoc_insertion_point(serialize_end:GCVersion)
}

::google::protobuf::uint8* GCVersion::SerializeWithCachedSizesToArray(
    ::google::protobuf::uint8* target) const {
  // @@protoc_insertion_point(serialize_to_array_start:GCVersion)
  // optional int32 version = 1;
  if (has_version()) {
    target = ::google::protobuf::internal::WireFormatLite::WriteInt32ToArray(1, this->version(), target);
  }

  if (!unknown_fields().empty()) {
    target = ::google::protobuf::internal::WireFormat::SerializeUnknownFieldsToArray(
        unknown_fields(), target);
  }
  // @@protoc_insertion_point(serialize_to_array_end:GCVersion)
  return target;
}

int GCVersion::ByteSize() const {
  int total_size = 0;

  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    // optional int32 version = 1;
    if (has_version()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::Int32Size(
          this->version());
    }

  }
  if (!unknown_fields().empty()) {
    total_size +=
      ::google::protobuf::internal::WireFormat::ComputeUnknownFieldsSize(
        unknown_fields());
  }
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = total_size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
  return total_size;
}

void GCVersion::MergeFrom(const ::google::protobuf::Message& from) {
  GOOGLE_CHECK_NE(&from, this);
  const GCVersion* source =
    ::google::protobuf::internal::dynamic_cast_if_available<const GCVersion*>(
      &from);
  if (source == NULL) {
    ::google::protobuf::internal::ReflectionOps::Merge(from, this);
  } else {
    MergeFrom(*source);
  }
}

void GCVersion::MergeFrom(const GCVersion& from) {
  GOOGLE_CHECK_NE(&from, this);
  if (from._has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    if (from.has_version()) {
      set_version(from.version());
    }
  }
  mutable_unknown_fields()->MergeFrom(from.unknown_fields());
}

void GCVersion::CopyFrom(const ::google::protobuf::Message& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

void GCVersion::CopyFrom(const GCVersion& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool GCVersion::IsInitialized() const {

  return true;
}

void GCVersion::Swap(GCVersion* other) {
  if (other != this) {
    std::swap(version_, other->version_);
    std::swap(_has_bits_[0], other->_has_bits_[0]);
    _unknown_fields_.Swap(&other->_unknown_fields_);
    std::swap(_cached_size_, other->_cached_size_);
  }
}

::google::protobuf::Metadata GCVersion::GetMetadata() const {
  protobuf_AssignDescriptorsOnce();
  ::google::protobuf::Metadata metadata;
  metadata.descriptor = GCVersion_descriptor_;
  metadata.reflection = GCVersion_reflection_;
  return metadata;
}


// ===================================================================

#ifndef _MSC_VER
const int CGHappyRollBuyMoney::kBuyMoneyNumFieldNumber;
#endif  // !_MSC_VER

CGHappyRollBuyMoney::CGHappyRollBuyMoney()
  : ::google::protobuf::Message() {
  SharedCtor();
  // @@protoc_insertion_point(constructor:CGHappyRollBuyMoney)
}

void CGHappyRollBuyMoney::InitAsDefaultInstance() {
}

CGHappyRollBuyMoney::CGHappyRollBuyMoney(const CGHappyRollBuyMoney& from)
  : ::google::protobuf::Message() {
  SharedCtor();
  MergeFrom(from);
  // @@protoc_insertion_point(copy_constructor:CGHappyRollBuyMoney)
}

void CGHappyRollBuyMoney::SharedCtor() {
  _cached_size_ = 0;
  buymoneynum_ = 0;
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

CGHappyRollBuyMoney::~CGHappyRollBuyMoney() {
  // @@protoc_insertion_point(destructor:CGHappyRollBuyMoney)
  SharedDtor();
}

void CGHappyRollBuyMoney::SharedDtor() {
  if (this != default_instance_) {
  }
}

void CGHappyRollBuyMoney::SetCachedSize(int size) const {
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
}
const ::google::protobuf::Descriptor* CGHappyRollBuyMoney::descriptor() {
  protobuf_AssignDescriptorsOnce();
  return CGHappyRollBuyMoney_descriptor_;
}

const CGHappyRollBuyMoney& CGHappyRollBuyMoney::default_instance() {
  if (default_instance_ == NULL) protobuf_AddDesc_HappyRollMessage_2eproto();
  return *default_instance_;
}

CGHappyRollBuyMoney* CGHappyRollBuyMoney::default_instance_ = NULL;

CGHappyRollBuyMoney* CGHappyRollBuyMoney::New() const {
  return new CGHappyRollBuyMoney;
}

void CGHappyRollBuyMoney::Clear() {
  buymoneynum_ = 0;
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
  mutable_unknown_fields()->Clear();
}

bool CGHappyRollBuyMoney::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!(EXPRESSION)) goto failure
  ::google::protobuf::uint32 tag;
  // @@protoc_insertion_point(parse_start:CGHappyRollBuyMoney)
  for (;;) {
    ::std::pair< ::google::protobuf::uint32, bool> p = input->ReadTagWithCutoff(127);
    tag = p.first;
    if (!p.second) goto handle_unusual;
    switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // optional int32 buyMoneyNum = 1;
      case 1: {
        if (tag == 8) {
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::int32, ::google::protobuf::internal::WireFormatLite::TYPE_INT32>(
                 input, &buymoneynum_)));
          set_has_buymoneynum();
        } else {
          goto handle_unusual;
        }
        if (input->ExpectAtEnd()) goto success;
        break;
      }

      default: {
      handle_unusual:
        if (tag == 0 ||
            ::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_END_GROUP) {
          goto success;
        }
        DO_(::google::protobuf::internal::WireFormat::SkipField(
              input, tag, mutable_unknown_fields()));
        break;
      }
    }
  }
success:
  // @@protoc_insertion_point(parse_success:CGHappyRollBuyMoney)
  return true;
failure:
  // @@protoc_insertion_point(parse_failure:CGHappyRollBuyMoney)
  return false;
#undef DO_
}

void CGHappyRollBuyMoney::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // @@protoc_insertion_point(serialize_start:CGHappyRollBuyMoney)
  // optional int32 buyMoneyNum = 1;
  if (has_buymoneynum()) {
    ::google::protobuf::internal::WireFormatLite::WriteInt32(1, this->buymoneynum(), output);
  }

  if (!unknown_fields().empty()) {
    ::google::protobuf::internal::WireFormat::SerializeUnknownFields(
        unknown_fields(), output);
  }
  // @@protoc_insertion_point(serialize_end:CGHappyRollBuyMoney)
}

::google::protobuf::uint8* CGHappyRollBuyMoney::SerializeWithCachedSizesToArray(
    ::google::protobuf::uint8* target) const {
  // @@protoc_insertion_point(serialize_to_array_start:CGHappyRollBuyMoney)
  // optional int32 buyMoneyNum = 1;
  if (has_buymoneynum()) {
    target = ::google::protobuf::internal::WireFormatLite::WriteInt32ToArray(1, this->buymoneynum(), target);
  }

  if (!unknown_fields().empty()) {
    target = ::google::protobuf::internal::WireFormat::SerializeUnknownFieldsToArray(
        unknown_fields(), target);
  }
  // @@protoc_insertion_point(serialize_to_array_end:CGHappyRollBuyMoney)
  return target;
}

int CGHappyRollBuyMoney::ByteSize() const {
  int total_size = 0;

  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    // optional int32 buyMoneyNum = 1;
    if (has_buymoneynum()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::Int32Size(
          this->buymoneynum());
    }

  }
  if (!unknown_fields().empty()) {
    total_size +=
      ::google::protobuf::internal::WireFormat::ComputeUnknownFieldsSize(
        unknown_fields());
  }
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = total_size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
  return total_size;
}

void CGHappyRollBuyMoney::MergeFrom(const ::google::protobuf::Message& from) {
  GOOGLE_CHECK_NE(&from, this);
  const CGHappyRollBuyMoney* source =
    ::google::protobuf::internal::dynamic_cast_if_available<const CGHappyRollBuyMoney*>(
      &from);
  if (source == NULL) {
    ::google::protobuf::internal::ReflectionOps::Merge(from, this);
  } else {
    MergeFrom(*source);
  }
}

void CGHappyRollBuyMoney::MergeFrom(const CGHappyRollBuyMoney& from) {
  GOOGLE_CHECK_NE(&from, this);
  if (from._has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    if (from.has_buymoneynum()) {
      set_buymoneynum(from.buymoneynum());
    }
  }
  mutable_unknown_fields()->MergeFrom(from.unknown_fields());
}

void CGHappyRollBuyMoney::CopyFrom(const ::google::protobuf::Message& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

void CGHappyRollBuyMoney::CopyFrom(const CGHappyRollBuyMoney& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool CGHappyRollBuyMoney::IsInitialized() const {

  return true;
}

void CGHappyRollBuyMoney::Swap(CGHappyRollBuyMoney* other) {
  if (other != this) {
    std::swap(buymoneynum_, other->buymoneynum_);
    std::swap(_has_bits_[0], other->_has_bits_[0]);
    _unknown_fields_.Swap(&other->_unknown_fields_);
    std::swap(_cached_size_, other->_cached_size_);
  }
}

::google::protobuf::Metadata CGHappyRollBuyMoney::GetMetadata() const {
  protobuf_AssignDescriptorsOnce();
  ::google::protobuf::Metadata metadata;
  metadata.descriptor = CGHappyRollBuyMoney_descriptor_;
  metadata.reflection = CGHappyRollBuyMoney_reflection_;
  return metadata;
}


// @@protoc_insertion_point(namespace_scope)

// @@protoc_insertion_point(global_scope)
